---
layout: post
title: 【note】C++
date: 2023-7-12 
tags: C++
---

*[翁凯老师C++课程笔记](https://www.bilibili.com/video/BV1dE41167hJ/)*（每一小节的序号略有调整）。

# 1 The First C++ Program

```C++
#include <iostream> //文件名不是一定要有后缀的
using namespace std; // Keyword + name

int main(){
    cout << "Hello World! I am" << "18" << "today!" << endl;

    return 0;
}
```

&emsp;&emsp;输入：**cin >>**

```C++
#include <iostream> 
using namespace std; 

int main(){

    int age;
    cin >> age;
    cout << "You are " << age << ".";

    return 0;
}
```

擅用refactor: 重构

# 2 面向对象（Object-oriented）

## 2.1 什么是面向对象

&emsp;&emsp;Object = Entity

&emsp;&emsp;Object may be visible or invisible

&emsp;&emsp;在程序设计中，对象就是变量。如：int i; i 就是一个对象
（Object is variable in programming languages.）

&emsp;&emsp;C++中，所有的对象都会以变量的形式出现

&emsp;&emsp;对象(Objects)= 属性(Attributes) + 服务(Services)

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/object.png" width=200px>
    <center>
    <figcaption>对象</figcaption>
    </center>
</figure>

&emsp;&emsp;数据Data：属性或状态（the properties or status）

&emsp;&emsp;操作Operations：对外提供的服务（the functions）

&emsp;&emsp;对象对外有一个接口

&emsp;&emsp;Mapping(映射)：From the problem space to the solution one.

&emsp;&emsp;举例子：上课，定义一个教室，教室里有学生、老师、投影仪、电脑等，它们之间互相有一定的关系，将这个关系描述出来就是面向对象，从存在什么样的东西来分析事情，而不是从发生流程来描述一个事情。

&emsp;&emsp;从某种程度上说，C++中的class就是C中的struct

### 同一段程序C和C++对比

**C Version**
```C
typedef struct point3d{
    float x;
    float y;
    float z;
}Point3d;

void Point3d_print(const Point3d* pd);
Point3d a;
a.x=1; a.y=2; a.z=3;
Point3d_print(&a);
```

**C++ Version**
```C++
class Point3d{
public:
    Point3d(float x, float y, float z);
    print();
private:
    float x;
    float y;
    float z;
};

Point3d a(1, 2, 3); //a是一个对象
a.print(); //operation
```

&emsp;&emsp;二者不同在于：C++操作在内部，class中有数据有操作。C的操作在外面，struct中只有操作。

&emsp;&emsp;A way to organize: Designs and Implementations.

&emsp;&emsp;对象才是Design和implementation首要关注的东西，而不是控制或数据流。

**&emsp;&emsp;To focus on things, not operations!**

## 2.2 面向对象基本概念

&emsp;&emsp;对象是互相之间在发送和接收消息。Objects send messages

### Objects send messages!

&emsp;&emsp;Messages are:

* &emsp;&emsp;composed by the sender
* &emsp;&emsp;interpreted by the receiver
* &emsp;&emsp;implemented by methods
  
&emsp;&emsp;Messages:

* &emsp;&emsp;May cause receiver to change state
* &emsp;&emsp;May return results

&emsp;&emsp;也就是说，不是在直接操作data，而是在改变operations！

### Object VS. Class

&emsp;&emsp;对象（实体）是东西，类（概念）是东西的种类。

&emsp;&emsp;杯子是一个类，我手里的杯子是一个对象。

&emsp;&emsp;**OOP Characteristics：**

* &emsp;&emsp;a. Everything is an object.
* &emsp;&emsp;b. A program is a bunch of objects telling each other what to do by sending messages.
* &emsp;&emsp;c. Each object has its own memory made up of other objects.
* &emsp;&emsp;d. Every object has a type.
* &emsp;&emsp;e. All objects of a particular type can receive the same messages

&emsp;&emsp;每一个对象有其自己的内存和类型。

&emsp;&emsp;一个特定类型的所有对象可接受相同的消息。所有可以接受相同消息的对象可以被认为是相同的类型。

&emsp;&emsp;**对象都具有接口**，对象用接口接收消息，接口的功能有Communication和Protection（保护内部的东西）。

&emsp;&emsp;**OOP三大特性：封装，继承，多态**

### 封装（Encapsulation）

&emsp;&emsp;把数据和对数据所有的操作放在一起，操作在外，数据在内。

&emsp;&emsp;隐藏数据和操作的细节。

&emsp;&emsp;外界只能访问公开的部分

# 3 类

## 3.1 以售货机为例实现一个类

&emsp;&emsp;每一个类都应该包含一个.h文件和一个.cpp文件。命名通常每个单词首字母大写。

TicketMachine.h ：
```C++
#ifndef TICKETMACHINE_TICKETMACHINE_H
#define TICKETMACHINE_TICKETMACHINE_H


class TicketMachine {
public:
    TicketMachine();
    virtual ~TicketMachine();
    void showPrompt();
    void insertMoney(int money);
    void showBalance();
    void printTicket();
    void showTotal();
private:
    const int PRICE;
    int balance;
    int total;

};


#endif //TICKETMACHINE_TICKETMACHINE_H
```

TicketMachine.cpp:

```C++
#include "TicketMachine.h"
#include <iostream>

using namespace std;

TicketMachine::TicketMachine() : PRICE(0){

}

TicketMachine::~TicketMachine() {

}

void TicketMachine::showPrompt() {
    cout << "something";
}

void TicketMachine::insertMoney(int money) {
    balance += money;
}

void TicketMachine::showBalance() {
    cout << balance;
}
```

main.cpp:
```C++
#include <iostream>
#include "TicketMachine.h"

int main() {
    TicketMachine tm;
    tm.insertMoney(100);
    tm.showBalance();

    return 0;
}
```

**&emsp;&emsp;特别说明：**

```C++
<Class Name>::<function name>
::<function name>
```

**&emsp;&emsp;::的含义：域的解析符，::前有类的名字表示函数或变量属于这个类，如果没有东西则表示一个全局的函数或变量**

```C++
void S::f(){
    ::f(); //全局的f()
    ::a++; //全局a
    a--; //类中的a
}
```

## 3.2 头文件

&emsp;&emsp;在头文件中包含类的声明（Class declaration）和函数的原型（prototypes），函数内容（body）放在.cpp中。注意调用头文件内容时要先include该头文件。一个头文件只声明一个类。

&emsp;&emsp;**头文件 = 接口（interface）**

&emsp;&emsp;#include：编译预处理指令。

### Declarations VS. Definitions

* &emsp;&emsp;一个.cpp就是一个编译单元
* &emsp;&emsp;只有declarations才能放在.h文件中：外部变量（extern variables）; 函数原型（function prototypes）；类和结构体的声明。

&emsp;&emsp;#include “xx.h” :在当前目录寻找头文件。 

&emsp;&emsp;#include <xx.h> :在系统目录寻找头文件。

&emsp;&emsp;#include <xx> :与第二种相同。

### 标准头文件结构

```
#ifndef 
#define

#endif
```

&emsp;&emsp;**使用这种结构是为了防止重复定义**

## 3.3 用C++实现时钟

### 抽象（Abstract）

&emsp;&emsp;Abstract is the ability to ignore details of parts to focus attention on a higher level of a problem.

## 3.4 成员变量

&emsp;&emsp;三种变量：Fields（成员变量）、parameters（函数参数）、local variables（局部变量）

* &emsp;&emsp;All three kinds of variables are able to store a value that is appropriate to their defined type.
  
* &emsp;&emsp;Fields are defined outside construators and methods.
  
* &emsp;&emsp;Fields are used to store data that persists throughout the life of an object. As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object class.
  
* &emsp;&emsp;Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.

&emsp;&emsp;局部变量与全局变量命名重复，程序按就近原则处理。

&emsp;&emsp;成员变量：在类的所有函数中可以直接使用，属于类的每一个对象。**而函数则是属于类，不属于对象。**

```C++
class A{
public:
    void f();
private:
    int i; // 这里的i是声明declaration而不是定义definition
};

void A::f(){
    int j = 10;

    cout << i << endl;
    i = 20; // A的i
    cout << i << endl;
}

int main(){
    A a; 
    a.i = 10;
    cout << i << endl;
    a.f();
    cout << i << endl;

    return 0;
}
```

&emsp;&emsp;上述程序会输出：
```
10
10
20
20
```

### 成员变量的秘密

&emsp;&emsp;当用不同对象调用同一个函数时，函数"知道"是哪个对象在调用它。

```C++
Point a;
a.print();
```

&emsp;&emsp;There is a relationship with the function be called and the variable calls it.

&emsp;&emsp;The function itself knows it is doing something with the variable.

### this : the hidden parameter

&emsp;&emsp;**this** : 所有的成员函数都具有的一个隐藏参数，类型是class。

&emsp;&emsp;*void Point::print()* 可以写成 *void Point::print(Point *p)*。

```C++
class A{
public:
    void f();
private:
    int i; 
};

void A::f(){
    this->i = 20;
    printf("A::f()--&i=%p\n", &i);
    printf("this=%p", this); //this 和 i 是一样的地址
}
```

&emsp;&emsp;在成员函数中可以用this来指代变量。this不能被定义，但是可以直接使用。

## 3.5 构造与析构

&emsp;&emsp;**init变量很重要！构造函数用于确保init。**

### 构造函数（constructor）

&emsp;&emsp;构造函数名字与类相同，且没有返回类型，会在类被创建时自动被调用。构造函数也是一种成员函数。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/构造函数.png" width=400px>
    <center>
    <figcaption>构造函数与被调用的过程示意</figcaption>
    </center>
</figure>

&emsp;&emsp;构造函数也可以有参数，参数传递方法是在构造对象时在后面加一个圆括号。

```C++
Tree(int i) {...}
Tree t(12);
```

### 析构函数（destructor）

&emsp;&emsp;析构函数以类名称命名，并在前面加 ~ 符号。析构函数不含有参数。

```C++
class Y{
public:
    ~Y();
};
```

&emsp;&emsp;**析构意味着对象所占用的空间被收回，析构函数会在{}（scope）结束后被调用。**

# 4 初始化

## 4.1 对象初始化

### 存储分配

&emsp;&emsp;编译器会在{}开始就分配空间，但是构造函数是从定义对象开始的。

```C++
int main(){ //分配空间
    A a;
    a.i = 10;
    printf("&a = %p\n", &a);
    printf("&a.i = %p\n", &(a.i));
    A aa; //constructor happen
    a.f();
    printf("&aa = %p\n", &aa);
    aa.f();
}
```
&emsp;&emsp;C++中struct和class某种程度上是一样的，struct也可以有构造函数。

### default constructor

&emsp;&emsp;A default constructor is one that can be called with no arguments. 默认构造函数无参数。

## 4.2 new & delete

### 动态内存分配

```C++
new int;
new int[10];
new stash //一个类

delete p; 
delete[] p; //new 带[]则delete带[]
```

&emsp;&emsp;delete时，先析构，再收回空间。

### 动态数组

&emsp;&emsp;`int * psome = new int [10];`：动态分配一块10个int类型数据大小的空间。

&emsp;&emsp;`delete [] psome`：[]代表告诉程序delete整个数组大小的空间而不是只有第一个元素，`psome`所指的全部内容的析构都会被调用。无`[]`的话空间会被回收，但是析构只有一个会被调用。

```C++
int *a  = new int[10];

a++

delete [] a; // 会出错
```

### 在程序中对比 delete 和 delete[] 

**delete version :**

&emsp;&emsp;**newdelete.h** :

```C++
#ifndef NEW_DELETE_NEWDELETE_H
#define NEW_DELETE_NEWDELETE_H

#include <iostream>

using namespace std;

class A{
private:
    int i;
public:
    A();
    ~A();
   void set(int i);
   void f();
};

#endif //NEW_DELETE_NEWDELETE_H
```

&emsp;&emsp;**newdelete.cpp** :

```C++
#include "newdelete.h"

A::A() {
    int i;
    cout << "A::A()" << endl;
}

A::~A() {
    cout << "A::~A(), i = "<< i << endl;
}

void A::set(int i) {
    this->i = i;
}

void A::f() {
    cout << "hello" << endl;
}
```

&emsp;&emsp;**main.cpp** :
```C++
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete p;

    return 0;
}
```

&emsp;&emsp;程序输出为：

```C++
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 0
```

&emsp;&emsp;new的顺序是反过来的，使用delete只会析构一次。

**delete[] version :**

&emsp;&emsp;将main函数中的`delete`替换成`delete[]`

```C++
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete[] p;

    return 0;
}
```

&emsp;&emsp;输出结果如下：

```C++
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 9
A::~A(), i = 8
A::~A(), i = 7
A::~A(), i = 6
A::~A(), i = 5
A::~A(), i = 4
A::~A(), i = 3
A::~A(), i = 2
A::~A(), i = 1
A::~A(), i = 0
```

### Tips for new and delete

* &emsp;&emsp;不要用delete释放不是被new分配的空间。
* &emsp;&emsp;不要用delete重复释放同一块空间。
* &emsp;&emsp;delete[] 和 new[] 对应。
* &emsp;&emsp;delete 和 new 对应。
* &emsp;&emsp;可以用delete释放空指针（null pointer）。

```C++
int *p  = 0;

delete p  //可以编译通过
```

&emsp;&emsp;这能简化代码编写，实际上，若在类中声明了一个指针并在构造函数将其定义为一个null pointer，那么析构函数有两种不同的写法。以下面的程序为例：

**first version :**

```C++
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

&emsp;&emsp;对于上述程序，当f()函数没有被调用过时，p是空指针，delete是safe的。当f()函数被调用过后，p不再是空指针，delete依然safe。

**更加保险的Version :**

```C++
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

### delete的意义

**&emsp;&emsp;对于循环的无法关闭的程序，如手机程序等等，避免内存泄露！**

## 4.3 访问限制（Setting limits）

&emsp;&emsp;这里解释为什么有 `public` 和 `private` 之分。

&emsp;&emsp;To keep the client programmer's hands off members they should not touch.

&emsp;&emsp;To allow the library designer to change the internal workings of the structure without worring about how it will affect the client programmer.

&emsp;&emsp;对于C++来说，所有的成员有如下三种访问属性：

* &emsp;&emsp;pubic：公开
* &emsp;&emsp;private：类的成员函数可以访问
* &emsp;&emsp;protected：类自己和其子类可以访问

```C++
#include <iostream>

using namespace std;

class A{
private:
    int i;
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void set(int ii) {i = ii;}
    void f() { p = new int; }
    void g(A* q) { cout << "A::g(), q->i = "<< i << endl;}
};

int main(){
    A* p = new A[10];
    for(i=0; i<10; i++>){
        p[i].set(i);
    }

    A b;
    b.set(100);
    p[0].g(&b);
    delete p;

    return 0;
}
```

&emsp;&emsp;**`prviate`是对类来说的，而不是对对象来说的，同一个类的对象之间可以互相访问私有的成员变量。**因此上面的程序能够正常运行，将输出`A::g(), q->i = 100`。

&emsp;&emsp;C++的OOP特性只在源代码层面存在。只有在编译阶段才会检查是public还是private。

### 友元Friends

&emsp;&emsp;声明一个“朋友”，这个“朋友”可以访问private属性的东西。

```C++
struct X;

struct Y{
    void f(X*);
};

struct X{
private:
    int i;
public:
    void initialize();
    friend void g(X*, int); //Global friend
    friend void Y::f(X*); //Struct member friend
    friend struct Z; //Entire struct is a friend
    friend void h();
};

void X::initialize() {
    i = 0;
}

void g(X* x, int i) {
    x->i = i;
}

void Y::f(X* x) {
    x->i = 57;
}

struct Z {
private:
    int j;
}
```

### class VS. struct

&emsp;&emsp;C++中`class`与`struct`唯一的区别在于当不声明`private`还是`public`时，`class`默认为`private`而`struct`默认为`public`。

## 4.4 初始化列表

```C++
class Point{
private:
    const float x, y;
    Point(float xa = 0.0, float ya = 0.0):y(ya), x(xa) {}
};
```

&emsp;&emsp;x, y的初始化会早于构造函数执行。

### Initialization(初始化) VS. assignment(赋值)

**初始化：**

```C++
Student::Student(string s):name(s) {}
```

**赋值：**

```C++
Student::Student(string s) {name = s；}
```

&emsp;&emsp;这种方式先初始化了，再赋值。

&emsp;&emsp;string must have a default constructor.

&emsp;&emsp;**类中的所有成员变量都用initialize list来做初始化！不要在构造函数里面做赋值！**

# 5 软件重用

## 5.1 对象组合

&emsp;&emsp;组合：用已有的对象来制造新的对象的过程.

&emsp;&emsp;组合有两种方式：

* &emsp;&emsp;Fully：另一个对象是当前对象的一部分。（成员变量是对象本身）
* &emsp;&emsp;By reference：当前对象可以访问另一个对象，可以调用，但是它不属于当前对象的一部分。（成员变量是指针）

&emsp;&emsp;形象的比喻，孩子在母亲肚子里面时是Fully，出生后则是By reference。

&emsp;&emsp;从程序的角度来说，当设计一个“人”的对象，心脏应该是fully的（在里面）而书包一个是By reference的（在外面）。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/组合对象.png" width=400px>
    <center>
    <figcaption>Fully & By reference</figcaption>
    </center>
</figure>

```C++
class Person {...};
class Currency {...};
class SavingAccount {
public:
    SavingAccount(const char* name, const char* address, int cents);
    ~SavingAccount();
    void print();
private:
    Person m_saver; //Fully 自己初始化自己，自己管理自己
    Currency m_balance; //Fully
};
```

&emsp;&emsp;`m_saver`和`m_balance`要遵守原来的“规范”，自己初始化自己，自己管理自己。

```C++
SavingAccount::SavingAccount(const char* name, const char* address, int cents): m_saver(name, address), m_balance(0, cents) {}

void SavingAccount::print() {
    m_saver.print();
    m_balance.print();
}
```

&emsp;&emsp;**这里用了初始化列表的方式来初始化`m_saver`和`m_balance`，使得二者的初始化在`SavingAccount`之前执行。如果不这样做，就要求`Person`和`Currency`两个类有default constructor。**

&emsp;&emsp;Initialize list 就是用来做这件事情的，如果类中有成员变量里面有对象，那么它应该在initialize list中完成初始化。

### Public VS. Private

&emsp;&emsp;It is common to make embedded objects private:

* &emsp;&emsp;they are parts of the underlying implementation.
* &emsp;&emsp;the new class only has parts of the public interface of the old class.

&emsp;&emsp;Can embed as a public object if you want to have the entire public interface of the subobject availaavaible in the new object.

```C++
class SavingAccount{
public:
    Person m_saver; // 假设Person类有set_name()函数
    ...
};

SavingAccount account;
account.m_saver.set_name("Fred");
```

## 5.2 继承（Inheritance）

&emsp;&emsp;继承：用已有的类来改造得到一个新的类。继承也是软件重用的一种方式。

&emsp;&emsp;继承和组合的区别在于，前者是用类来做出一个新的类，而后者则是用对象来制造一个新的对象。组合是“实”的，而继承是“虚”的。

&emsp;&emsp;继承使得我们可以共享设计中的成员函数、成员变量和接口（interface 指一个类的public部分）。

&emsp;&emsp; The ability to define the behaviour or implementation of one class as the **superset** （超集，数学概念）of another class.

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/superset继承.png" width=200px>
    <center>
    <figcaption>“学生”继承“人，因为学生是人！</figcaption>
    </center>
</figure>

&emsp;&emsp;**注意，superclass指的是Person类，指“超类”，这是一个计算机概念。而superset指Student类，指“超集”，这是一个数学概念。**

&emsp;&emsp;继承一个类的时候，一定会对这个类进行扩充！

&emsp;&emsp;当有两个存在继承关系的类时，通常画图时将被继承的类放在上面，继承的类放在下面。

**程序表达：**

```C++
class A{
    ...
};

class B : public A{ 
    ...
};
```

&emsp;&emsp;B继承A，是A的子类。public是必需的！

&emsp;&emsp;父类私有的变量是不能被继承的子类直接改变的。而如果父类中的某函数或变量是protected属性，那么子类可以对其进行操作。这里我的理解是想要操作protected中的东西，那操作者必需是class，而不能是定义的class类型的对象，这也解释了为什么视频中程序（下面写）b.set（）是会报错的。protected属性的东西提供了一个接口，子类通过这个接口可以间接改变private属性的内容。

**Inheritance.h:**
```C++
#ifndef INHERITANCE_INHERITANCE_H
#define INHERITANCE_INHERITANCE_H

#include <iostream>

using namespace std;

class Father {
private:
    int i;
protected:
    void change(int j); // 提供了改变i的接口
public:
    Father();
    ~Father();
    void print();
    void set(int ii);
};

class Son : public Father {
public:
    void f();
};


#endif //INHERITANCE_INHERITANCE_H

```

**Inheritance.cpp:**
```C++
#include "Inheritance.h"

Father::Father() : i(0) {
    cout << "Father::Father()" << endl;
}

Father::~Father() {
    cout << "Father::~Father()" << endl;
}

void Father::set(int ii) {
    i = ii;
}

void Father::print() {
    cout << "Father::f(), i = " << i << endl;
}

void Father::change(int j) {
    i = j;
}

void Son::f() {
    set(100);
    print();
    change(200);
    print();
}

```

**main.cpp:**
```C++
#include "Inheritance.h"

int main() {

    Son s;
    s.f();
    // s.change(2); 这条语句会报错，因为对象s不能直接操作protected属性的内容。
    s.set(1);
    s.print();

    return 0;
}
```

&emsp;&emsp;上述程序将输出：

```C++
Father::Father()
Father::f(), i = 100
Father::f(), i = 200
Father::f(), i = 1
Father::~Father()
```

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/关系图.png" width=500px>
    <center>
    <figcaption>Scopes and access in C++</figcaption>
    </center>
</figure>

## 5.3 子类父类关系

```C++
#include <iostream>

using namespace std;

class A{
private:
    int i;
public:
    A(int ii):i(ii) { cout << "A::A()" << endl; }
    ~A() { cout << "A::~A()" << endl; }
    void print() { cout << "A::f()" << i << endl; }
    void print(int i) {cout << i << endl; print();} //重载函数
    void set(int ii) { i = ii; }
};

class B : public A {
public:
    B() : A(15) { cout << "B::B()" << endl; } //这里，必须对A的构造函数初始化
    ~B() { cout << "B::~B()" << endl; }
    void print() { cout << "B::print()" << endl; }
    void f() {
        set(20);
        print();
    }
};

int main(){
    B b;
    b.set(10);
    b.print();
}

```

&emsp;&emsp;父类构造函数调用，放在子类构造函数的initialize list里。

&emsp;&emsp;基类通常会被先构造。

&emsp;&emsp;如果没有明确的参数传递给基类，则default constructor会被调用。

&emsp;&emsp;析构的顺序和构造的顺序相反。

&emsp;&emsp;**父类当中有重载函数，子类中出现和父类重复的函数（参数、名字都一样），则子类只有自己的这个函数，父类的那个函数就被隐藏掉了。（比较拗口！），以上面的程序为例说明此事：**

```C++
int main(){
    b.print(20); // 会报错
}
```

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/报错.png" width=800px>
    <center>
    <figcaption>报错内容：no mathing function for call to ...</figcaption>
    </center>
</figure>

&emsp;&emsp;如果想调用`A类`中的`print(int i)`函数，则需如下写法：

```C++
int main(){
    b.A::print(20); 
}
```

&emsp;&emsp;**以程序为进一步说明：**

**Inheritance.h:**
```C++
#ifndef INHERITANCE_INHERITANCE_H
#define INHERITANCE_INHERITANCE_H

#include <iostream>

using namespace std;

class Father {
private:
    int i;
protected:
    void change(int j);
public:
    Father();
    ~Father();
    void print();
    void print(int i);
    void set(int ii);
};

class Son : public Father {
public:
    void f();
    void print();
};

#endif //INHERITANCE_INHERITANCE_H
```

**Inheritance.cpp:**
```C++
//
// Created by PC on 2023-07-30.
//

#include "Inheritance.h"

Father::Father() : i(0) {
    cout << "Father::Father()" << endl;
}

Father::~Father() {
    cout << "Father::~Father()" << endl;
}

void Father::set(int ii) {
    i = ii;
}

void Father::print() {
    cout << "Father::f(), i = " << i << endl;
}

void Father::print(int i) {
    cout << i << endl;
    print();
}

void Father::change(int j) {
    i = j;
}

void Son::f() {
    set(100);
    print();
    change(200);
    print();
}

void Son::print() {
    cout << "Son::print()" << endl;
}
```

**main.cpp:**
```C++
#include "Inheritance.h"

int main() {

    Son s;
    s.f();
    s.set(1);
    s.print();

    s.Father::print(20);

    return 0;
}
```

&emsp;&emsp;输出：

```C++
Son::print() //其实这里也说明了，前面输出的是Father::f(), i = 100，这里变成了子类的print，说明父类的被隐藏了。若要调用父类中的print函数也是要在前面加上::域的解析符。
Son::print()
Son::print()
20
Father::f(), i = 1
Father::~Father()

```

# 6 函数

## 6.1 函数重载和默认参数（缺省参数值）

&emsp;&emsp;两个函数名称相同，参数表相同，返回类型不同不能重载。重载一定是参数表不同。

&emsp;&emsp;Default arguments：A default arguments is a value given in the declaration that the complier automatically inserts if you don not provide a value in the function call.

```C++
Stash(int size, int initQuantity = 0);
```

&emsp;&emsp;To define a function with an argument list, defaults must be added from **right to left**. 必须从右到左。

```C++
int f(int i, int j = 1, int m = 2);
int g(int i, int j = 1, int m ); // illeagle
int h(int i = 0, int j = 1, int m = 2)

beeps = f(2); // i = 2
beeps = f(1, 8); // i = 1, j = 8
beeps  = f(5, 6, 7); // i = 5, j = 6, m = 7 
```

&emsp;&emsp;Default arguments must be written in `.h` file but not in `.cpp` file.

&emsp;&emsp;建议不要使用default value!

## 6.2 内联函数

&emsp;&emsp;调用函数时有一些overhead（额外的开销）。  

&emsp;&emsp;inline function 内联函数能够帮助减少overhead，提高成运行速度。与常规函数的区别在于内联函数的编译代码与其他程序代码“内联”起来了。编译器会使用相应的函数代码替换函数调用，也就是说，内联代码程序无序调到另一处执行代码再跳回来。因此，内联函数的运行速度比常规函数快。这是从汇编语言的层面上的理解方式！

&emsp;&emsp;内联函数需要占用更多的内存，如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。（C++ primer plus）

&emsp;&emsp;Repeat `inline` keyword at declaration and definition. 即，头文件和cpp文件都要写 inline 关键字

&emsp;&emsp;An inline function definition may not generate any code in .obj file.

&emsp;&emsp;Never be afraid of multi-definition of inline functions, since they have no body at all.

&emsp;&emsp;Definitions of inline functions are just declarations. 在函数前面加了`inline`以后，就不再是定义而是声明了！所以应该将内联函数的body放在头文件中，当需要调用这个函数时`#include`即可。

&emsp;&emsp;inline函数实际上是一种以空间换时间的策略。inline函数与C中的宏类似，但是宏是不可以做类型检查的，因此inline安全。

### Inline may not in-line

&emsp;&emsp;编译器有可能会拒绝inline。如果函数过大或者是递归的，那么编译器可以拒绝。

### Inline inside classes

&emsp;&emsp;**Any function you define inside a class declaration is automatically an inline.**

&emsp;&emsp;在类中将函数body写在函数后面就是inline！

```C++
class Rectangle {
    int width, height;
public:
    Rectangle ( int w = 0, int h = 0 ); // inline的写法
    int getWidth() const;
    void setWidth(int w);
    int getHeight() const;
    void setHeight(int h);
}

inline Rectangle::Rectangle(int w, int h) : width(w), height(h) {}

inline Rectangle::getWidth() const {
    return width;
}
```

&emsp;&emsp;在类的下面写inline的声明，使得代码简洁。

### Inline or not?

&emsp;&emsp;Inline:

* &emsp;&emsp;Small functions, 2 or 3 lines.
* &emsp;&emsp;Frequently called functions, e.g. inside loops

&emsp;&emsp;Not inline:

* &emsp;&emsp;Very large functions, more than 20 lines.
* &emsp;&emsp;Recursive functions.（递归函数）

## 6.3 Const

&emsp;&emsp;const变量依然是变量，而不是常数。

&emsp;&emsp;**const int bufsize = 1024;**

* &emsp;&emsp;value must be initialized
* &emsp;&emsp;unless you make an explicit extern declaration
  
&emsp;&emsp;**extern const int bufsize;**

* &emsp;&emsp;compiler will not let you change it

```C++
const int class_size = 12;
int finalGrade[class_size]; //OK

int x;
cin >> x;
const int size = x;
double classAverage[size]; // error!因为编译的时候不知道x
```

### Pointers and const

&emsp;&emsp;A pointer may be const. Meanwhile, a value may also be a const.

```C++
char * const q = "abc"; // q is const
*q = 'c'; //OK
q++; // error!
```

```C++
const char *p = "ABCD";
// (*p) is a const char
*p = 'b'; // Error! (*p) is the const 
```

&emsp;&emsp;const 在\*号前就是对象是const。

&emsp;&emsp;const 在\*号后就是指针是const。**不能通过指针修改对象，但是不意味着对象是const的了！**

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/const.png" width=500px>
    <center>
    <figcaption>const对象和指针</figcaption>
    </center>
</figure>

&emsp;&emsp;

&emsp;&emsp;上图中为什么`cip = &ci`是可行的？因为cip保证了通过`*cip`不能修改指向对象的内容！

```C++
char s2[] = "hello world";

char *s1 = "hello world"; //等价于const char *s1 = "hello world";
```

&emsp;&emsp;s1在代码段中，不可修改，s2在堆栈中，可以修改。

### Passing and returning address ！

&emsp;&emsp;**Passing a whole object may cost you a lot. It is better to pass by a pointer. But it is possible for the programmer to take it and modify the original value.**

&emsp;&emsp;**In fact, whenever you are passing an address into a function, you should make it a `const` if at all possible!**

### Constant objects & Const member functions

&emsp;&emsp;对象是const的：

```C++
const Currency cur(1, 2);
```

&emsp;&emsp;函数是const的：

```C++
int Date::get_day() const {
    day++; // error!
    set_day(12); // error!

    return day;
}
```

&emsp;&emsp;函数是const的意味着该函数不修改任何成员变量。

### Const member function usage

&emsp;&emsp;Repeat the const keyword in the definition as well as the declaration.

```C++
int get_day() const;

int get_dat() const {return day};
```

&emsp;&emsp;Function members that do not modify data should be declared const.

&emsp;&emsp;const member functions are safe for const objects!

&emsp;&emsp;`this`是const的！

```C++
class A {
    int i;
public:
    A : i(0) {}
    void f() {cout << "f()" << endl;}
    void f() const {cout << "f() const" << endl;}
};

int main(){
    const A a;
    a.f();

    return 0;
}
```

&emsp;&emsp;两个f()函数能构成overload的本质原因是：

```C++
void f(A* this)
void f(const A* this)
```

&emsp;&emsp;调用的时候因为a是const，所以会选择const的函数调用。

&emsp;&emsp;**成员变量如果是const的，那么必须在initilaizer list中将其初始化。**

## 6.4 引用

&emsp;&emsp;通过引用来访问一个对象。

&emsp;&emsp;References are a new type in C++.

```C++
char& r = c; //引用
```

&emsp;&emsp;全局变量或局部变量初始化时必须赋值，成员变量则不需要，会在构造函数时初始化初值。

&emsp;&emsp;引用是声明了一个新的`name`给已存在的变量。

```C++
int X = 47;
int& Y  = X; // Y is a reference to X

// X 和 Y 现在是同一个变量

cout << "Y  = " << Y; // Y = 47
Y = 18;
cout << "X  = " << X; // X = 18
```

### 引用的规则

* References must be initialized when defined.
* Initialization establishes a binding.

&emsp;&emsp;声明中：

```C++
int x = 3;
int& y = x;
const int& z = x; //通过z不能修改x
```

&emsp;&emsp;函数参数中：

```C++
void f( int& x );
f(y); // initialized when function is called
```

* Bindigs do not change at run time, unlike pointers.
* Assignment changes the object referred-to.

```C++
int& y = x;
y = 12; // changes value of x
```
* The target of a reference must have a location

```C++
void func(int &);
func ( i*3 ); //Warning or error! i*3 has no location!
```

### Poninters VS. References

&emsp;&emsp;**实际上，引用就是const pointers**，设计引用的目的就是减少\*号。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/reference.png" width=500px>
    <center>
    <figcaption>引用和指针的区别</figcaption>
    </center>
</figure>

&emsp;&emsp;引用类型不能互相赋值。

### 限制

&emsp;&emsp;No references to references.

&emsp;&emsp;No pointers to refereneces.

```C++
int&* p; //illegal 不能取得reference的地址
```

&emsp;&emsp;Reference to pointer is ok.

```C++
void f(int*& p); 
```
&emsp;&emsp;p是一个引用，它所bind的变量是一个指针。

&emsp;&emsp;No arrays of references.

## 6.5 向上造型（upcast）

&emsp;&emsp;子类对象被当做父类看待，同样还有向下造型（downcast）。

```C++
Manager pete("Pete", "111-111-111","Bakery");
Employee* ep = &pete; //Upcast
Employee& er = pete; //Upcast
```

## 6.6 多态性（Polymorphism）

&emsp;&emsp;**virtual函数**在通过指针或引用调用时不能确定是哪个，只有给了参数以后才能够确定，这里的参数就具有多态性，即指的是谁，就变成谁的形态！

&emsp;&emsp;多态性建立在两个东西的基础上，一个是upcast，另一个是dynamic binding。

* Upcast: take an object of the derived class as an object of the base one.
* Dynamic binding: binding——which function to be called. Call the function of the object. 运行时才知道调用的是哪个函数。（Static binding: call the function as the code. —— （编译时就知道调用是哪个函数）

## 6.7 多态的实现

&emsp;&emsp;任何一个类如果有虚函数，这个类的对象就会比正常的大一点。

```C++
#include <iostream>
using namspace std;

class A {
public:
    A() : i(10) {}
    virtual void f() {cout << "A::f()" << i << endl; }

    int i;
};

int main(){
    A a;
    a.f();
    cout << sizeof(a) << endl;

    int *p = (int*)&a;
    p++;
    cout << *p << endl; //输出为10

    return 0;
}
```

&emsp;&emsp;所有有virtual的类的对象在头上会有一个隐藏的`vptr`指针，指向存放所有virtual函数地址的`vtable`表。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/vptr指针.png" width=300px>
    <center>
    <figcaption>vptr指针指向vtable</figcaption>
    </center>
</figure>

```C++
#include <iostream>
using namspace std;

class A {
public:
    A() : i(10) {}
    virtual void f() {cout << "A::f()" << i << endl; }

    int i;
};

class B : public A {
public:
    B() : j(20) {}
    virtual void f() { cout << "B::f()" << j << endl;}

    int j;
};

int main(){
    A a;
    B b;

    A* p = &b;
    
    p->f(); // 执行的是b的f()

    a = b;

    a.f(); // 执行的是a的f()

    p = &a;
    p->f(); // 执行的是a的f()

    return 0;
}
```

&emsp;&emsp;在`a = b`的过程中，`vptr`不传递。

```C++
#include <iostream>
using namspace std;

class A {
public:
    A() : i(10) {}
    virtual void f() {cout << "A::f()" << i << endl; }

    int i;
};

class B : public A {
public:
    B() : j(20) {}
    virtual void f() { cout << "B::f()" << j << endl;}

    int j;
};

int main(){
    A a;
    B b;

    A* p = &a;

    int* r = (int*)&a;
    int* t = (int*)&b;

    *r = *t;
    
    p->f(); // 执行的是b的f()

    return 0;
}
```

&emsp;&emsp;改变了`vptr`。

&emsp;&emsp;**如果类中有一个virtual函数，则析构函数必须是virtual的！**

&emsp;&emsp;Overide：父类和子类的两个函数是virtual的，且名称相同参数也相同，就构成overiding关系（覆盖或改写）。在这种关系下，想调用父类的函数，需要加`Bass::`作用域。 

&emsp;&emsp;如果`D`是`B`的子类，`D::f()`能够返回`B::f()`的指针和引用类型。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/Relaxation.png" width=400px>
    <center>
    <figcaption>返回对象本身错误</figcaption>
    </center>
</figure>

&emsp;&emsp;父类里面有virtual的两个overloaded的函数，在子类里面必须override所有的virtual函数，否则会发生name hidding。

## 6.8 引用再研究

### References as class members

&emsp;&emsp;**Declared without initial value.**

&emsp;&emsp;**Must be initialized using constructor initializer list.**

```C++
class X {
public:
    int& m_y;
    X(int& a);
};

X::X(int& a) : m_y(a) {}
```

### Returning references

&emsp;&emsp;Functions can return references. But they better refer to non-local variables!

&emsp;&emsp;返回引用时，返回的是一个直接的变量（值）。

&emsp;&emsp;以程序为例说明：

```C++
#include <iostream>
using namespace;

double myarray[10] = {0};

double& subscript (int i){
    return myarray[i]; // 函数类型是引用，返回的实际上是数组的值
}

int main() {
    double value = subscript(12);
    subscript(3) = 12.5;
}
```

### Const in Functions Arguments

&emsp;&emsp;**使用指针或引用是常用的对象参数传递方式，并在前面加上const，保证函数不能修改该对象。引用是一种更好的用法，好处是省略了\*号。**

```C++
person(const string& name, int weight);
```

### Const in Function returns

&emsp;&emsp;返回一个const的value

```C++
#include <iostream>
using namespace std;

class A {
public:
    int i;
    A() : i(0) {}    
};

A f (){
    A a;
    return a;
}

int main(){
    f().i = 10;

    A b;
    b.i = 20;
    f() = b;

    return 0;
}
```

&emsp;&emsp;f()函数返回的是一个对象，所以可以做左值。如果是`const A f()`则不能做左值，因为返回的对象是`const`的。

## 6.9 拷贝构造——The copy constructor

&emsp;&emsp;拷贝构造：

```C++
T::T(const T&);
```

&emsp;&emsp;做成员变量对成员变量的拷贝——成员级别的拷贝，而不是字节对字节的拷贝。

&emsp;&emsp;下面都是初始化initialization
```C++
Person baby_a("A");
// these use the copy ctor

Person baby_b = baby_a; //not an assignment
Person baby_c(baby_a); //not an assignment
```

&emsp;&emsp;编译器有时会优化“冗余”的拷贝。

```C++
Person copy_func(char *who) {
    Person local(who);
    local.print();
    return local; // 此时copy ctor called
}

Person nocopy_func(char *who) {
    return Person(who); // 此时no copy needed!，因为和Person无关
}
```

&emsp;&emsp;在C++中要使用`string`类。

&emsp;&emsp;**一旦写了一个类，一定要给它三个函数：** 

* &emsp;&emsp;default constructor
* &emsp;&emsp;virtual destructor
* &emsp;&emsp;copy constructor

&emsp;&emsp;关于拷贝构造，我觉得黑马程序员的课程讲解更通俗一些，因此在这里放上他们课程的笔记：

### 黑马程序员课程关于拷贝构造的笔记

#### 拷贝构造函数调用时机

&emsp;&emsp;C++中拷贝构造函数调用时机通常有三种情况

* &emsp;&emsp;使用一个已经创建完毕的对象来初始化一个新对象
* &emsp;&emsp;值传递的方式给函数参数传值
* &emsp;&emsp;以值方式返回局部对象

&emsp;&emsp;**示例：**

```C++
class Person {
public:
	Person() {
		cout << "无参构造函数!" << endl;
		mAge = 0;
	}
	Person(int age) {
		cout << "有参构造函数!" << endl;
		mAge = age;
	}
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		mAge = p.mAge;
	}
	//析构函数在释放内存之前调用
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int mAge;
};

//1. 使用一个已经创建完毕的对象来初始化一个新对象
void test01() {

	Person man(100); //p对象已经创建完毕
	Person newman(man); //调用拷贝构造函数
	Person newman2 = man; //拷贝构造

	//Person newman3;
	//newman3 = man; //不是调用拷贝构造函数，赋值操作
}

//2. 值传递的方式给函数参数传值
//相当于Person p1 = p;
void doWork(Person p1) {}
void test02() {
	Person p; //无参构造函数
	doWork(p);
}

//3. 以值方式返回局部对象
Person doWork2()
{
	Person p1;
	cout << (int *)&p1 << endl;
	return p1;
}

void test03()
{
	Person p = doWork2();
	cout << (int *)&p << endl;
}


int main() {

	//test01();
	//test02();
	test03();

	system("pause");

	return 0;
}
```

#### 构造函数调用规则

&emsp;&emsp;默认情况下，c++编译器至少给一个类添加3个函数

&emsp;&emsp;1．默认构造函数(无参，函数体为空)

&emsp;&emsp;2．默认析构函数(无参，函数体为空)

&emsp;&emsp;3．默认拷贝构造函数，对属性进行值拷贝

&emsp;&emsp;构造函数调用规则如下：

* &emsp;&emsp;如果用户定义有参构造函数，c++不再提供默认无参构造，但是会提供默认拷贝构造
* &emsp;&emsp;如果用户定义拷贝构造函数，c++不会再提供其他构造函数

&emsp;&emsp;示例：

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int a) {
		age = a;
		cout << "有参构造函数!" << endl;
	}
	//拷贝构造函数
	Person(const Person& p) {
		age = p.age;
		cout << "拷贝构造函数!" << endl;
	}
	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
	}
public:
	int age;
};

void test01()
{
	Person p1(18);
	//如果不写拷贝构造，编译器会自动添加拷贝构造，并且做浅拷贝操作
	Person p2(p1);

	cout << "p2的年龄为： " << p2.age << endl;
}

void test02()
{
	//如果用户提供有参构造，编译器不会提供默认构造，会提供拷贝构造
	Person p1; //此时如果用户自己没有提供默认构造，会出错
	Person p2(10); //用户提供的有参
	Person p3(p2); //此时如果用户没有提供拷贝构造，编译器会提供

	//如果用户提供拷贝构造，编译器不会提供其他构造函数
	Person p4; //此时如果用户自己没有提供默认构造，会出错
	Person p5(10); //此时如果用户自己没有提供有参，会出错
	Person p6(p5); //用户自己提供拷贝构造
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

#### 深拷贝与浅拷贝

&emsp;&emsp;深浅拷贝是面试经典问题，也是常见的一个坑

&emsp;&emsp;浅拷贝：简单的赋值拷贝操作

&emsp;&emsp;深拷贝：在堆区重新申请空间，进行拷贝操作

&emsp;&emsp;**示例：**

```C++
class Person {
public:
	//无参（默认）构造函数
	Person() {
		cout << "无参构造函数!" << endl;
	}
	//有参构造函数
	Person(int age ,int height) {
		
		cout << "有参构造函数!" << endl;

		m_age = age;
		m_height = new int(height);
		
	}
	//拷贝构造函数  
	Person(const Person& p) {
		cout << "拷贝构造函数!" << endl;
		//如果不利用深拷贝在堆区创建新内存，会导致浅拷贝带来的重复释放堆区问题
		m_age = p.m_age;
		m_height = new int(*p.m_height);
		
	}

	//析构函数
	~Person() {
		cout << "析构函数!" << endl;
		if (m_height != NULL)
		{
			delete m_height;
		}
	}
public:
	int m_age;
	int* m_height;
};

void test01()
{
	Person p1(18, 180);

	Person p2(p1);

	cout << "p1的年龄： " << p1.m_age << " 身高： " << *p1.m_height << endl;

	cout << "p2的年龄： " << p2.m_age << " 身高： " << *p2.m_height << endl;
}

int main() {

	test01();

	system("pause");

	return 0;
}
```

> &emsp;&emsp;总结：如果属性有在堆区开辟的，一定要自己提供拷贝构造函数，防止浅拷贝带来的问题

## 6.10 静态对象

&emsp;&emsp;Static member variables: Shared by all instances.

&emsp;&emsp;Static member function: Shared by all instances, can only access static member variables.

&emsp;&emsp;当函数中有一个static的本地变量时，这个static的local variable 就是全局变量。

## 6.11 静态成员

&emsp;&emsp;Static means: Hidden and Persistent. Persistent 意味着static成员变量或函数不依赖于对象的存在而存在，是共享的。

```C++
#include <iostream>
using namespace std;

class A {
public: 
    A() { i = 0 };
    void print() {cout << i << endl;}
    void set(int ii) {i = ii};
    static int j;
    static say(int k) {cout << k << i << endl;}
private:
    static int i; //declaration声明，而不是definition
};

int A::i; // 有static的成员变量必须在某一个cpp文件里面写这样一句话来定义这个static成员变量
int A::j = 10;

int main(){
    A a,b;
    a.set(10);
    b.print();

    a.say(0);
    A::say(0);//两种方式调用public属性的静态成员函数

    cout << a.j << endl;
    cout << A::j << endl; //两种方式访问public属性的静态成员变量

    return 0;
}
```

&emsp;&emsp;**有static的成员变量必须在某一个cpp文件里面定义这个static成员变量: int A::i;, 而不能在initialize list中初始化。**

&emsp;&emsp;两种方式访问public属性的静态成员变量：

```C++
    cout << a.j << endl;
    cout << A::j << endl;
```

&emsp;&emsp;两种方式调用public属性的静态成员函数：

```C++
    a.say(0);
    A::say(0);
```

&emsp;&emsp;**静态函数只能调用静态成员函数，访问静态成员变量，原因如下：**

&emsp;&emsp;**静态成员变量没有隐藏参数this。因此上面的程序不能写`this->i。`**

# 7 运算符重载 —— Overloading Operators

## 7.1 基本规则

&emsp;&emsp;写函数改变运算符的行为，可以不使用默认运算功能，而使用重新定义过的功能进行运算。

&emsp;&emsp可以能重载的运算符如下：

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/运算符.png" width=400px>
    <center>
    <figcaption>可以重载的运算符</figcaption>
    </center>
</figure>

&emsp;&emsp;不能重载的运算符如下：

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/不能重载的运算符.png" width=400px>
    <center>
    <figcaption>不可以重载的运算符</figcaption>
    </center>
</figure>

### 限制

* &emsp;&emsp;只有已经存在的运算符可以重载。
* &emsp;&emsp;只能对一个类或枚举类型来重载运算符。
* &emsp;&emsp;运算符重载必须保证原有操作数的个数和优先级。

&emsp;&emsp;Use the `operator` keyword as a prefix to name

```C++
operator *(...)
```

&emsp;&emsp;可以作为成员函数，已有hidden parameter —— `this`。

```C++
const String String::operator +(const String& that); 
```

&emsp;&emsp;可以作为全局函数

```C++
const String operator +(const String& r, const String& l); 
```

&emsp;&emsp;As member function:

* &emsp;&emsp;this 是它的第一个参数
* &emsp;&emsp;No type conversion performed on recevier
* &emsp;&emsp;Must have access to class definition

```C++
class Integer {
public:
    Integer(int n = 0) : i(n) {}
    const Integer operator+(const Integer& n) const{
        return Integer(i + n.i)
    }
private:
    int i;
};
```

&emsp;&emsp;如何使用：

```C++
Integer x(1), y(5), z;
x + y; 
```

&emsp;&emsp;这里的x + y 实际上是`x.operator+(y)`。从而我们引出了一个新的概念——receiver。运算符的左边是receiver。

&emsp;&emsp;前面所说的*No type conversion performed on recevier*的意思是：receiver决定了operator用哪个，当receiver是`Integer`时，就是使用重载的\+号。

```C++
z = x + y; //可行
z = x + 3; //可行
z = 3 + y; //不可行
```

&emsp;&emsp;`z = x + 3`可行是因为，当receiver是x，使用的加法是重载后的\+，3可以被转换成一个`Integer`类型的对象。而`z = 3 + y`不可行是因为使用的是正常的\+。

### Operator as a global function

```C++
const Integer operator+(const Integer& rhs, const Integer& lhs);

Integer x, y;
```

&emsp;&emsp;对`private`属性的成员变量进行运算时需要在类中被声明为友元  `friend`。

&emsp;&emsp;Type conversions performed on both arguments.

```C++
class Integer {
    friend const Integer operator+(const Integer& rhs, const Integer& lhs);
}

const Integer operator+(const Integer& rhs, const Integer& lhs) {
    return Integer(lhs.i + rhs.i);
}
```

&emsp;&emsp;此时，`z = 3 + y`可行。

* &emsp;&emsp;Unary oprators（单目运算符） should be members.
* &emsp;&emsp;= () -> ->* must be memberss.
* &emsp;&emsp;assignment operators should be members.
* &emsp;&emsp;All other binary operators（双目运算符） as non-members.

## 7.2 原型

### 参数传递——Argument Passing

&emsp;&emsp;运算符不修改算子的（read-only），传递参数时要加const，以reference的形式传递。而像++、--这样的算子则可以不加const。

&emsp;&emsp;成员函数不能修改类，要声明const。Make member functions const that do not change the class (boolean operators, +, -, etc).

&emsp;&emsp;全局函数可能两个都是const，或者有一个不加。

### 返回值——Return Values

&emsp;&emsp;决定返回的东西是对自己修改还是制造了一个新东西。

&emsp;&emsp;For operator+ you need to generate a new object. Return as a const object so the result can not be modified as an Ivalue.

&emsp;&emsp;Logical operators should return bool (or int for older compilers).

### The prototypes of operators

&emsp;&emsp;**常见运算符：**

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/原型1.png" width=400px>
    <center>
    <figcaption></figcaption>
    </center>
</figure>

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/原型2.png" width=400px>
    <center>
    <figcaption>++、--运算符重载</figcaption>
    </center>
</figure>

&emsp;&emsp;prefix代表++a，postfix代表a++，二者通过后面有无int参数进行区分。

```C++
const Integer& Integer::operator++() {
    *this += 1;
    return *this;
}

const Integer Integer::operator(int) {
    Integer old(*this); //拷贝构造
    ++(*this); //用上面的++来定义这个++
    return old;
}
```

&emsp;&emsp;**关系运算符：**

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/关系运算符1.png" width=400px>
    <center>
    <figcaption>关系运算符</figcaption>
    </center>
</figure>

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/关系运算符2.png" width=400px>
    <center>
    <figcaption>关系运算符</figcaption>
    </center>
</figure>

&emsp;&emsp;可以看出：

* implement `!=` in terms of `==`.
* implement`>`, `>=`, `<=`, in terms of `<`.

&emsp;&emsp;实际上只定义了==和<两个原函数，好处是如果要改变行为只要改两个就行了

&emsp;&emsp;**index运算符[]：**

&emsp;&emsp;必须是成员函数，且只有单一参数。

&emsp;&emsp;返回引用类型：

```C++
Vector v(100);  //create a vector of size 100
v[10] = 45;
```

&emsp;&emsp;返回指针类型：

```C++
*v[10] = 45;
```

## 7.3 赋值

```C++
class Fi {
public:
    Fi() {}
};

class Fee {
public:
    Fee(int) {}
    Fee(const Fi&) {}
};

int main() {
    Fee fee = 1; // Fee(int)
    Fi fi;
    Fee fum = fi; // Fee(Fi)
    fum = fi; //先构造一个Fee的对象，再赋值给fum
}
```

### Assignment operator

&emsp;&emsp;Must be a member function.

&emsp;&emsp;Check for assignment to self.对自己做赋值。

&emsp;&emsp;返回一个*this。

```C++
A = B = C;
// executed as
A = (B = C);
```

```C++
T& T::operator=(const T& rhs) {
    if (this != &rhs) {
        // perform assignment
    } //这里是必须的，看起来无用，但是实际上有用，在下面的程序段中说明
    return *this;
}
```

```C++
class A {
    char *p;
    A& operator=(cosnt A& that){
        delete p;

        p = new [strlen(that.p)+1];

        strcpy(p, that.p);

        return *this;
    }
}
```

&emsp;&emsp;在上面的类中，如果that就是this，那么p会被先delete掉，从而后面的that.p毫无意义。

&emsp;&emsp;For classes with dynamically allocated memory declare an assignment operator (and a copy constructor).

&emsp;&emsp;To prevent assignment, explicitly declare operator= as private.

## 7.4 类型转换

&emsp;&emsp;Value class: 如复数complex，字符串string等。这种类与原来的数据类型相似，能被传递或作为返回类型，通常有重载操作符，且能够由其他类型转换得到或被转换成其他类型。

```C++
class one {
public:
    one() {}
};

class two {
    string name
public:
    two (const one&) {}
    explicit three (cosnt string&) {}
    ~two();
};

void f(two) {}

int main() {
    one one, one1;
    f(one);

    string abc("abc");
    two xyz(abc); // OK!
    xyz = abc; // error!
}
```

&emsp;&emsp;最后得`f(one)`看似类型不匹配，但是实际上发生的是先调用构造函数将one转换成two再把这个two类型的参数给f()。

&emsp;&emsp;若要防止这种自动的隐藏的类型转换，需要在成员函数前加`explicit`关键字。

&emsp;&emsp;也可以写转换操作符Conversion operations：

&emsp;&emsp;
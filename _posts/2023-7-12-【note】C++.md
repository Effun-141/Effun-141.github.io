---
layout: post
title: 【note】C++
date: 2023-7-12 
tags: C++
---

*[翁凯老师C++课程笔记](https://www.bilibili.com/video/BV1dE41167hJ/)*（每一小节的序号略有调整）。

# 1 The First C++ Program

```
#include <iostream> //文件名不是一定要有后缀的
using namespace std; // Keyword + name

int main(){
    cout << "Hello World! I am" << "18" << "today!" << endl;

    return 0;
}
```

&emsp;&emsp;输入：**cin >>**

```
#include <iostream> 
using namespace std; 

int main(){

    int age;
    cin >> age;
    cout << "You are " << age << ".";

    return 0;
}
```

擅用refactor: 重构

# 2 面向对象（Object-oriented）

## 2.1 什么是面向对象

&emsp;&emsp;Object = Entity

&emsp;&emsp;Object may be visible or invisible

&emsp;&emsp;在程序设计中，对象就是变量。如：int i; i 就是一个对象
（Object is variable in programming languages.）

&emsp;&emsp;C++中，所有的对象都会以变量的形式出现

&emsp;&emsp;对象(Objects)= 属性(Attributes) + 服务(Services)

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/object.png" width=200px>
    <center>
    <figcaption>对象</figcaption>
    </center>
</figure>

&emsp;&emsp;数据Data：属性或状态（the properties or status）

&emsp;&emsp;操作Operations：对外提供的服务（the functions）

&emsp;&emsp;对象对外有一个接口

&emsp;&emsp;Mapping(映射)：From the problem space to the solution one.

&emsp;&emsp;举例子：上课，定义一个教室，教室里有学生、老师、投影仪、电脑等，它们之间互相有一定的关系，将这个关系描述出来就是面向对象，从存在什么样的东西来分析事情，而不是从发生流程来描述一个事情。

&emsp;&emsp;从某种程度上说，C++中的class就是C中的struct

### 同一段程序C和C++对比

**C Version**
```
typedef struct point3d{
    float x;
    float y;
    float z;
}Point3d;

void Point3d_print(const Point3d* pd);
Point3d a;
a.x=1; a.y=2; a.z=3;
Point3d_print(&a);
```

**C++ Version**
```
class Point3d{
public:
    Point3d(float x, float y, float z);
    print();
private:
    float x;
    float y;
    float z;
};

Point3d a(1, 2, 3); //a是一个对象
a.print(); //operation
```

&emsp;&emsp;二者不同在于：C++操作在内部，class中有数据有操作。C的操作在外面，struct中只有操作。

&emsp;&emsp;A way to organize: Designs and Implementations.

&emsp;&emsp;对象才是Design和implementation首要关注的东西，而不是控制或数据流。

**&emsp;&emsp;To focus on things, not operations!**

## 2.2 面向对象基本概念

&emsp;&emsp;对象是互相之间在发送和接收消息。Objects send messages

### Objects send messages!

&emsp;&emsp;Messages are:

* &emsp;&emsp;composed by the sender
* &emsp;&emsp;interpreted by the receiver
* &emsp;&emsp;implemented by methods
  
&emsp;&emsp;Messages:

* &emsp;&emsp;May cause receiver to change state
* &emsp;&emsp;May return results

&emsp;&emsp;也就是说，不是在直接操作data，而是在改变operations！

### Object VS. Class

&emsp;&emsp;对象（实体）是东西，类（概念）是东西的种类。

&emsp;&emsp;杯子是一个类，我手里的杯子是一个对象。

&emsp;&emsp;**OOP Characteristics：**

* &emsp;&emsp;a. Everything is an object.
* &emsp;&emsp;b. A program is a bunch of objects telling each other what to do by sending messages.
* &emsp;&emsp;c. Each object has its own memory made up of other objects.
* &emsp;&emsp;d. Every object has a type.
* &emsp;&emsp;e. All objects of a particular type can receive the same messages

&emsp;&emsp;每一个对象有其自己的内存和类型。

&emsp;&emsp;一个特定类型的所有对象可接受相同的消息。所有可以接受相同消息的对象可以被认为是相同的类型。

&emsp;&emsp;**对象都具有接口**，对象用接口接收消息，接口的功能有Communication和Protection（保护内部的东西）。

&emsp;&emsp;**OOP三大特性：封装，继承，多态**

### 封装（Encapsulation）

&emsp;&emsp;把数据和对数据所有的操作放在一起，操作在外，数据在内。

&emsp;&emsp;隐藏数据和操作的细节。

&emsp;&emsp;外界只能访问公开的部分

# 3 类

## 3.1 以售货机为例实现一个类

&emsp;&emsp;每一个类都应该包含一个.h文件和一个.cpp文件。命名通常每个单词首字母大写。

TicketMachine.h ：
```
#ifndef TICKETMACHINE_TICKETMACHINE_H
#define TICKETMACHINE_TICKETMACHINE_H


class TicketMachine {
public:
    TicketMachine();
    virtual ~TicketMachine();
    void showPrompt();
    void insertMoney(int money);
    void showBalance();
    void printTicket();
    void showTotal();
private:
    const int PRICE;
    int balance;
    int total;

};


#endif //TICKETMACHINE_TICKETMACHINE_H
```

TicketMachine.cpp:

```
#include "TicketMachine.h"
#include <iostream>

using namespace std;

TicketMachine::TicketMachine() : PRICE(0){

}

TicketMachine::~TicketMachine() {

}

void TicketMachine::showPrompt() {
    cout << "something";
}

void TicketMachine::insertMoney(int money) {
    balance += money;
}

void TicketMachine::showBalance() {
    cout << balance;
}
```

main.cpp:
```
#include <iostream>
#include "TicketMachine.h"

int main() {
    TicketMachine tm;
    tm.insertMoney(100);
    tm.showBalance();

    return 0;
}
```

**&emsp;&emsp;特别说明：**

```
<Class Name>::<function name>
::<function name>
```

**&emsp;&emsp;::的含义：域的解析符，::前有类的名字表示函数或变量属于这个类，如果没有东西则表示一个全局的函数或变量**

```
void S::f(){
    ::f(); //全局的f()
    ::a++; //全局a
    a--; //类中的a
}
```

## 3.2 头文件

&emsp;&emsp;在头文件中包含类的声明（Class declaration）和函数的原型（prototypes），函数内容（body）放在.cpp中。注意调用头文件内容时要先include该头文件。一个头文件只声明一个类。

&emsp;&emsp;**头文件 = 接口（interface）**

&emsp;&emsp;#include：编译预处理指令。

### Declarations VS. Definitions

* &emsp;&emsp;一个.cpp就是一个编译单元
* &emsp;&emsp;只有declarations才能放在.h文件中：外部变量（extern variables）; 函数原型（function prototypes）；类和结构体的声明。

&emsp;&emsp;#include “xx.h” :在当前目录寻找头文件。 

&emsp;&emsp;#include <xx.h> :在系统目录寻找头文件。

&emsp;&emsp;#include <xx> :与第二种相同。

### 标准头文件结构

```
#ifndef 
#define

#endif
```

&emsp;&emsp;**使用这种结构是为了防止重复定义**

## 3.3 用C++实现时钟

### 抽象（Abstract）

&emsp;&emsp;Abstract is the ability to ignore details of parts to focus attention on a higher level of a problem.

## 3.4 成员变量

&emsp;&emsp;三种变量：Fields（成员变量）、parameters（函数参数）、local variables（局部变量）

* &emsp;&emsp;All three kinds of variables are able to store a value that is appropriate to their defined type.
  
* &emsp;&emsp;Fields are defined outside construators and methods.
  
* &emsp;&emsp;Fields are used to store data that persists throughout the life of an object. As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object class.
  
* &emsp;&emsp;Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.

&emsp;&emsp;局部变量与全局变量命名重复，程序按就近原则处理。

&emsp;&emsp;成员变量：在类的所有函数中可以直接使用，属于类的每一个对象。**而函数则是属于类，不属于对象。**

```
class A{
public:
    void f();
private:
    int i; // 这里的i是声明declaration而不是定义definition
};

void A::f(){
    int j = 10;

    cout << i << endl;
    i = 20; // A的i
    cout << i << endl;
}

int main(){
    A a; 
    a.i = 10;
    cout << i << endl;
    a.f();
    cout << i << endl;

    return 0;
}
```

&emsp;&emsp;上述程序会输出：
```
10
10
20
20
```

### 成员变量的秘密

&emsp;&emsp;当用不同对象调用同一个函数时，函数"知道"是哪个对象在调用它。

```
Point a;
a.print();
```

&emsp;&emsp;There is a relationship with the function be called and the variable calls it.

&emsp;&emsp;The function itself knows it is doing something with the variable.

### this : the hidden parameter

&emsp;&emsp;**this** : 所有的成员函数都具有的一个隐藏参数，类型是class。

&emsp;&emsp;*void Point::print()* 可以写成 *void Point::print(Point *p)*。

```
class A{
public:
    void f();
private:
    int i; 
};

void A::f(){
    this->i = 20;
    printf("A::f()--&i=%p\n", &i);
    printf("this=%p", this); //this 和 i 是一样的地址
}
```

&emsp;&emsp;在成员函数中可以用this来指代变量。this不能被定义，但是可以直接使用。

## 3.5 构造与析构

&emsp;&emsp;**init变量很重要！构造函数用于确保init。**

### 构造函数（constructor）

&emsp;&emsp;构造函数名字与类相同，且没有返回类型，会在类被创建时自动被调用。构造函数也是一种成员函数。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/构造函数.png" width=400px>
    <center>
    <figcaption>构造函数与被调用的过程示意</figcaption>
    </center>
</figure>

&emsp;&emsp;构造函数也可以有参数，参数传递方法是在构造对象时在后面加一个圆括号。

```
Tree(int i) {...}
Tree t(12);
```

### 析构函数（destructor）

&emsp;&emsp;析构函数以类名称命名，并在前面加 ~ 符号。析构函数不含有参数。

```
class Y{
public:
    ~Y();
};
```

&emsp;&emsp;**析构意味着对象所占用的空间被收回，析构函数会在{}（scope）结束后被调用。**

# 4 初始化

## 4.1 对象初始化

### 存储分配

&emsp;&emsp;编译器会在{}开始就分配空间，但是构造函数是从定义对象开始的。

```
int main(){ //分配空间
    A a;
    a.i = 10;
    printf("&a = %p\n", &a);
    printf("&a.i = %p\n", &(a.i));
    A aa; //constructor happen
    a.f();
    printf("&aa = %p\n", &aa);
    aa.f();
}
```
&emsp;&emsp;C++中struct和class某种程度上是一样的，struct也可以有构造函数。

### default constructor

&emsp;&emsp;A default constructor is one that can be called with no arguments. 默认构造函数无参数。

## 4.2 new & delete

### 动态内存分配

```
new int;
new int[10];
new stash //一个类

delete p; 
delete[] p; //new 带[]则delete带[]
```

&emsp;&emsp;delete时，先析构，再收回空间。

### 动态数组

&emsp;&emsp;`int * psome = new int [10];`：动态分配一块10个int类型数据大小的空间。

&emsp;&emsp;`delete [] psome`：[]代表告诉程序delete整个数组大小的空间而不是只有第一个元素，`psome`所指的全部内容的析构都会被调用。无`[]`的话空间会被回收，但是析构只有一个会被调用。

```
int *a  = new int[10];

a++

delete [] a; // 会出错
```

### 在程序中对比 delete 和 delete[] 

**delete version :**

&emsp;&emsp;**newdelete.h** :

```
#ifndef NEW_DELETE_NEWDELETE_H
#define NEW_DELETE_NEWDELETE_H

#include <iostream>

using namespace std;

class A{
private:
    int i;
public:
    A();
    ~A();
   void set(int i);
   void f();
};

#endif //NEW_DELETE_NEWDELETE_H
```

&emsp;&emsp;**newdelete.cpp** :

```
#include "newdelete.h"

A::A() {
    int i;
    cout << "A::A()" << endl;
}

A::~A() {
    cout << "A::~A(), i = "<< i << endl;
}

void A::set(int i) {
    this->i = i;
}

void A::f() {
    cout << "hello" << endl;
}
```

&emsp;&emsp;**main.cpp** :
```
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete p;

    return 0;
}
```

&emsp;&emsp;程序输出为：

```
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 0
```

&emsp;&emsp;new的顺序是反过来的，使用delete只会析构一次。

**delete[] version :**

&emsp;&emsp;将main函数中的`delete`替换成`delete[]`

```
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete[] p;

    return 0;
}
```

&emsp;&emsp;输出结果如下：

```
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 9
A::~A(), i = 8
A::~A(), i = 7
A::~A(), i = 6
A::~A(), i = 5
A::~A(), i = 4
A::~A(), i = 3
A::~A(), i = 2
A::~A(), i = 1
A::~A(), i = 0
```

### Tips for new and delete

* &emsp;&emsp;不要用delete释放不是被new分配的空间。
* &emsp;&emsp;不要用delete重复释放同一块空间。
* &emsp;&emsp;delete[] 和 new[] 对应。
* &emsp;&emsp;delete 和 new 对应。
* &emsp;&emsp;可以用delete释放空指针（null pointer）。

```
int *p  = 0;

delete p  //可以编译通过
```

&emsp;&emsp;这能简化代码编写，实际上，若在类中声明了一个指针并在构造函数将其定义为一个null pointer，那么析构函数有两种不同的写法。以下面的程序为例：

**first version :**

```
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

&emsp;&emsp;对于上述程序，当f()函数没有被调用过时，p是空指针，delete是safe的。当f()函数被调用过后，p不再是空指针，delete依然safe。

**更加保险的Version :**

```
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

### delete的意义

**&emsp;&emsp;对于循环的无法关闭的程序，如手机程序等等，避免内存泄露！**

## 4.3 访问限制（Setting limits）

&emsp;&emsp;这里解释为什么有 `public` 和 `private` 之分。

&emsp;&emsp;To keep the client programmer's hands off members they should not touch.

&emsp;&emsp;To allow the library designer to change the internal workings of the structure without worring about how it will affect the client programmer.

&emsp;&emsp;对于C++来说，所有的成员有如下三种访问属性：

* &emsp;&emsp;pubic：公开
* &emsp;&emsp;private：类的成员函数可以访问
* &emsp;&emsp;protected：类自己和其子类可以访问

```
#include <iostream>

using namespace std;

class A{
private:
    int i;
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void set(int ii) {i = ii;}
    void f() { p = new int; }
    void g(A* q) { cout << "A::g(), q->i = "<< i << endl;}
};

int main(){
    A* p = new A[10];
    for(i=0; i<10; i++>){
        p[i].set(i);
    }

    A b;
    b.set(100);
    p[0].g(&b);
    delete p;

    return 0;
}
```

&emsp;&emsp;**`prviate`是对类来说的，而不是对对象来说的，同一个类的对象之间可以互相访问私有的成员变量。**因此上面的程序能够正常运行，将输出`A::g(), q->i = 100`。

&emsp;&emsp;C++的OOP特性只在源代码层面存在。只有在编译阶段才会检查是public还是private。

### 友元Friends

&emsp;&emsp;声明一个“朋友”，这个“朋友”可以访问private属性的东西。

```
struct X;

struct Y{
    void f(X*);
};

struct X{
private:
    int i;
public:
    void initialize();
    friend void g(X*, int); //Global friend
    friend void Y::f(X*); //Struct member friend
    friend struct Z; //Entire struct is a friend
    friend void h();
};

void X::initialize() {
    i = 0;
}

void g(X* x, int i) {
    x->i = i;
}

void Y::f(X* x) {
    x->i = 57;
}

struct Z {
private:
    int j;
}
```

### class VS. struct

&emsp;&emsp;C++中`class`与`struct`唯一的区别在于当不声明`private`还是`public`时，`class`默认为`private`而`struct`默认为`public`。

## 4.4 初始化列表

```
class Point{
private:
    const float x, y;
    Point(float xa = 0.0, float ya = 0.0):y(ya), x(xa) {}
};
```

&emsp;&emsp;x, y的初始化会早于构造函数执行。

### Initialization(初始化) VS. assignment(赋值)

**初始化：**

```
Student::Student(string s):name(s) {}
```

**赋值：**

```
Student::Student(string s) {name = s；}
```

&emsp;&emsp;这种方式先初始化了，再赋值。

&emsp;&emsp;string must have a default constructor.

&emsp;&emsp;**类中的所有成员变量都用initialize list来做初始化！不要在构造函数里面做赋值！**

# 5 软件重用

## 5.1 对象组合

&emsp;&emsp;组合：用已有的对象来制造新的对象的过程.

&emsp;&emsp;组合有两种方式：

* &emsp;&emsp;Fully：另一个对象是当前对象的一部分。（成员变量是对象本身）
* &emsp;&emsp;By reference：当前对象可以访问另一个对象，可以调用，但是它不属于当前对象的一部分。（成员变量是指针）

&emsp;&emsp;形象的比喻，孩子在母亲肚子里面时是Fully，出生后则是By reference。

&emsp;&emsp;从程序的角度来说，当设计一个“人”的对象，心脏应该是fully的（在里面）而书包一个是By reference的（在外面）。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/组合对象.png" width=400px>
    <center>
    <figcaption>Fully & By reference</figcaption>
    </center>
</figure>

```
class Person {...};
class Currency {...};
class SavingAccount {
public:
    SavingAccount(const char* name, const char* address, int cents);
    ~SavingAccount();
    void print();
private:
    Person m_saver; //Fully 自己初始化自己，自己管理自己
    Currency m_balance; //Fully
};
```

&emsp;&emsp;`m_saver`和`m_balance`要遵守原来的“规范”，自己初始化自己，自己管理自己。

```
SavingAccount::SavingAccount(const char* name, const char* address, int cents): m_saver(name, address), m_balance(0, cents) {}

void SavingAccount::print() {
    m_saver.print();
    m_balance.print();
}
```

&emsp;&emsp;**这里用了初始化列表的方式来初始化`m_saver`和`m_balance`，使得二者的初始化在`SavingAccount`之前执行。如果不这样做，就要求`Person`和`Currency`两个类有default constructor。**

&emsp;&emsp;Initialize list 就是用来做这件事情的，如果类中有成员变量里面有对象，那么它应该在initialize list中完成初始化。

### Public VS. Private

&emsp;&emsp;It is common to make embedded objects private:

* &emsp;&emsp;they are parts of the underlying implementation.
* &emsp;&emsp;the new class only has parts of the public interface of the old class.

&emsp;&emsp;Can embed as a public object if you want to have the entire public interface of the subobject availaavaible in the new object.

```
class SavingAccount{
public:
    Person m_saver; // 假设Person类有set_name()函数
    ...
};

SavingAccount account;
account.m_saver.set_name("Fred");
```

## 5.2 继承（Inheritance）

&emsp;&emsp;继承：用已有的类来改造得到一个新的类。继承也是软件重用的一种方式。

&emsp;&emsp;继承和组合的区别在于，前者是用类来做出一个新的类，而后者则是用对象来制造一个新的对象。组合是“实”的，而继承是“虚”的。

&emsp;&emsp;继承使得我们可以共享设计中的成员函数、成员变量和接口（interface 指一个类的public部分）。

&emsp;&emsp; The ability to define the behaviour or implementation of one class as the **superset** （超集，数学概念）of another class.

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/superset继承.png" width=200px>
    <center>
    <figcaption>“学生”继承“人，因为学生是人！</figcaption>
    </center>
</figure>

&emsp;&emsp;**注意，superclass指的是Person类，指“超类”，这是一个计算机概念。而superset指Student类，指“超集”，这是一个数学概念。**

&emsp;&emsp;继承一个类的时候，一定会对这个类进行扩充！

&emsp;&emsp;当有两个存在继承关系的类时，通常画图时将被继承的类放在上面，继承的类放在下面。

**程序表达：**

```
class A{
    ...
};

class B : public A{ 
    ...
};
```

&emsp;&emsp;B继承A，是A的子类。public是必需的！

&emsp;&emsp;父类私有的变量是不能被继承的子类直接改变的。而如果父类中的某函数或变量是protected属性，那么子类可以对其进行操作。这里我的理解是想要操作protected中的东西，那操作者必需是class，而不能是定义的class类型的对象，这也解释了为什么视频中程序（下面写）b.set（）是会报错的。protected属性的东西提供了一个接口，子类通过这个接口可以间接改变private属性的内容。

**Inheritance.h:**
```
#ifndef INHERITANCE_INHERITANCE_H
#define INHERITANCE_INHERITANCE_H

#include <iostream>

using namespace std;

class Father {
private:
    int i;
protected:
    void change(int j); // 提供了改变i的接口
public:
    Father();
    ~Father();
    void print();
    void set(int ii);
};

class Son : public Father {
public:
    void f();
};


#endif //INHERITANCE_INHERITANCE_H

```

**Inheritance.cpp:**
```
#include "Inheritance.h"

Father::Father() : i(0) {
    cout << "Father::Father()" << endl;
}

Father::~Father() {
    cout << "Father::~Father()" << endl;
}

void Father::set(int ii) {
    i = ii;
}

void Father::print() {
    cout << "Father::f(), i = " << i << endl;
}

void Father::change(int j) {
    i = j;
}

void Son::f() {
    set(100);
    print();
    change(200);
    print();
}

```

**main.cpp:**
```
#include "Inheritance.h"

int main() {

    Son s;
    s.f();
    // s.change(2); 这条语句会报错，因为对象s不能直接操作protected属性的内容。
    s.set(1);
    s.print();

    return 0;
}
```

&emsp;&emsp;上述程序将输出：

```
Father::Father()
Father::f(), i = 100
Father::f(), i = 200
Father::f(), i = 1
Father::~Father()
```

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/关系图.png" width=500px>
    <center>
    <figcaption>Scopes and access in C++</figcaption>
    </center>
</figure>

## 5.3 子类父类关系

```
#include <iostream>

using namespace std;

class A{
private:
    int i;
public:
    A(int ii):i(ii) { cout << "A::A()" << endl; }
    ~A() { cout << "A::~A()" << endl; }
    void print() { cout << "A::f()" << i << endl; }
    void print(int i) {cout << i << endl; print();} //重载函数
    void set(int ii) { i = ii; }
};

class B : public A {
public:
    B() : A(15) { cout << "B::B()" << endl; } //这里，必须对A的构造函数初始化
    ~B() { cout << "B::~B()" << endl; }
    void print() { cout << "B::print()" << endl; }
    void f() {
        set(20);
        print();
    }
};

int main(){
    B b;
    b.set(10);
    b.print();
}

```

&emsp;&emsp;父类构造函数调用，放在子类构造函数的initialize list里。

&emsp;&emsp;基类通常会被先构造。

&emsp;&emsp;如果没有明确的参数传递给基类，则default constructor会被调用。

&emsp;&emsp;析构的顺序和构造的顺序相反。

&emsp;&emsp;**父类当中有重载函数，子类中出现和父类重复的函数（参数、名字都一样），则子类只有自己的这个函数，父类的那个函数就被隐藏掉了。（比较拗口！），以上面的程序为例说明此事：**

```
int main(){
    b.print(20); // 会报错
}
```

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/报错.png" width=800px>
    <center>
    <figcaption>报错内容：no mathing function for call to ...</figcaption>
    </center>
</figure>

&emsp;&emsp;如果想调用`A类`中的`print(int i)`函数，则需如下写法：

```
int main(){
    b.A::print(20); 
}
```

&emsp;&emsp;**以程序为进一步说明：**

**Inheritance.h:**
```
#ifndef INHERITANCE_INHERITANCE_H
#define INHERITANCE_INHERITANCE_H

#include <iostream>

using namespace std;

class Father {
private:
    int i;
protected:
    void change(int j);
public:
    Father();
    ~Father();
    void print();
    void print(int i);
    void set(int ii);
};

class Son : public Father {
public:
    void f();
    void print();
};

#endif //INHERITANCE_INHERITANCE_H
```

**Inheritance.cpp:**
```
//
// Created by PC on 2023-07-30.
//

#include "Inheritance.h"

Father::Father() : i(0) {
    cout << "Father::Father()" << endl;
}

Father::~Father() {
    cout << "Father::~Father()" << endl;
}

void Father::set(int ii) {
    i = ii;
}

void Father::print() {
    cout << "Father::f(), i = " << i << endl;
}

void Father::print(int i) {
    cout << i << endl;
    print();
}

void Father::change(int j) {
    i = j;
}

void Son::f() {
    set(100);
    print();
    change(200);
    print();
}

void Son::print() {
    cout << "Son::print()" << endl;
}
```

**main.cpp:**
```
#include "Inheritance.h"

int main() {

    Son s;
    s.f();
    s.set(1);
    s.print();

    s.Father::print(20);

    return 0;
}
```

&emsp;&emsp;输出：

```
Son::print() //其实这里也说明了，前面输出的是Father::f(), i = 100，这里变成了子类的print，说明父类的被隐藏了。若要调用父类中的print函数也是要在前面加上::域的解析符。
Son::print()
Son::print()
20
Father::f(), i = 1
Father::~Father()

```

# 6 函数

## 6.1 函数重载和默认参数（缺省参数值）

&emsp;&emsp;两个函数名称相同，参数表相同，返回类型不同不能重载。重载一定是参数表不同。

&emsp;&emsp;Default arguments：A default arguments is a value given in the declaration that the complier automatically inserts if you don not provide a value in the function call.

```
Stash(int size, int initQuantity = 0);
```

&emsp;&emsp;To define a function with an argument list, defaults must be added from **right to left**. 必须从右到左。

```
int f(int i, int j = 1, int m = 2);
int g(int i, int j = 1, int m ); // illeagle
int h(int i = 0, int j = 1, int m = 2)

beeps = f(2); // i = 2
beeps = f(1, 8); // i = 1, j = 8
beeps  = f(5, 6, 7); // i = 5, j = 6, m = 7 
```

&emsp;&emsp;Default arguments must be written in `.h` file but not in `.cpp` file.

&emsp;&emsp;建议不要使用default value!

## 6.2 内联函数

&emsp;&emsp;调用函数时有一些overhead（额外的开销）。  

&emsp;&emsp;inline function 内联函数能够帮助减少overhead，提高成运行速度。与常规函数的区别在于内联函数的编译代码与其他程序代码“内联”起来了。编译器会使用相应的函数代码替换函数调用，也就是说，内联代码程序无序调到另一处执行代码再跳回来。因此，内联函数的运行速度比常规函数快。这是从汇编语言的层面上的理解方式！

&emsp;&emsp;内联函数需要占用更多的内存，如果程序在10个不同的地方调用同一个内联函数，则该程序将包含该函数代码的10个副本。（C++ primer plus）

&emsp;&emsp;Repeat `inline` keyword at declaration and definition. 即，头文件和cpp文件都要写 inline 关键字

&emsp;&emsp;An inline function definition may not generate any code in .obj file.

&emsp;&emsp;Never be afraid of multi-definition of inline functions, since they have no body at all.

&emsp;&emsp;Definitions of inline functions are just declarations. 在函数前面加了`inline`以后，就不再是定义而是声明了！所以应该将内联函数的body放在头文件中，当需要调用这个函数时`#include`即可。

&emsp;&emsp;inline函数实际上是一种以空间换时间的策略。inline函数与C中的宏类似，但是宏是不可以做类型检查的，因此inline安全。

### Inline may not in-line

&emsp;&emsp;编译器有可能会拒绝inline。如果函数过大或者是递归的，那么编译器可以拒绝。

### Inline inside classes

&emsp;&emsp;**Any function you define inside a class declaration is automatically an inline.**

&emsp;&emsp;在类中将函数body写在函数后面就是inline！

```
class Rectangle {
    int width, height;
public:
    Rectangle ( int w = 0, int h = 0 ); // inline的写法
    int getWidth() const;
    void setWidth(int w);
    int getHeight() const;
    void setHeight(int h);
}

inline Rectangle::Rectangle(int w, int h) : width(w), height(h) {}

inline Rectangle::getWidth() const {
    return width;
}
```

&emsp;&emsp;在类的下面写inline的声明，使得代码简洁。

### Inline or not?

&emsp;&emsp;Inline:

* &emsp;&emsp;Small functions, 2 or 3 lines.
* &emsp;&emsp;Frequently called functions, e.g. inside loops

&emsp;&emsp;Not inline:

* &emsp;&emsp;Very large functions, more than 20 lines.
* &emsp;&emsp;Recursive functions.（递归函数）

## 6.3 Const

&emsp;&emsp;const变量依然是变量，而不是常数。

&emsp;&emsp;**const int bufsize = 1024;**

* &emsp;&emsp;value must be initialized
* &emsp;&emsp;unless you make an explicit extern declaration
  
&emsp;&emsp;**extern const int bufsize;**

* &emsp;&emsp;compiler will not let you change it

```
const int class_size = 12;
int finalGrade[class_size]; //OK

int x;
cin >> x;
const int size = x;
double classAverage[size]; // error!因为编译的时候不知道x
```

### Pointers and const

&emsp;&emsp;A pointer may be const. Meanwhile, a value may also be a const.

```
char * const q = "abc"; // q is const
*q = 'c'; //OK
q++; // error!
```

```
const char *p = "ABCD";
// (*p) is a const char
*p = 'b'; // Error! (*p) is the const 
```

&emsp;&emsp;const 在\*号前就是对象是const。

&emsp;&emsp;const 在\*号后就是指针是const。**不能通过指针修改对象，但是不意味着对象是const的了！**

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/const.png" width=500px>
    <center>
    <figcaption>const对象和指针</figcaption>
    </center>
</figure>

&emsp;&emsp;

&emsp;&emsp;上图中为什么`cip = &ci`是可行的？因为cip保证了通过`*cip`不能修改指向对象的内容！

```
char s2[] = "hello world";

char *s1 = "hello world"; //等价于const char *s1 = "hello world";
```

&emsp;&emsp;s1在代码段中，不可修改，s2在堆栈中，可以修改。

### Passing and returning address ！

&emsp;&emsp;**Passing a whole object may cost you a lot. It is better to pass by a pointer. But it is possible for the programmer to take it and modify the original value.**

&emsp;&emsp;**In fact, whenever you are passing an address into a function, you should make it a `const` if at all possible!**

### Constant objects & Const member functions

&emsp;&emsp;对象是const的：

```
const Currency cur(1, 2);
```

&emsp;&emsp;函数是const的：

```
int Date::get_day() const {
    day++; // error!
    set_day(12); // error!

    return day;
}
```

&emsp;&emsp;函数是const的意味着该函数不修改任何成员变量。

### Const member function usage

&emsp;&emsp;Repeat the const keyword in the definition as well as the declaration.

```
int get_day() const;

int get_dat() const {return day};
```

&emsp;&emsp;Function members that do not modify data should be declared const.

&emsp;&emsp;const member functions are safe for const objects!

&emsp;&emsp;`this`是const的！

```
class A {
    int i;
public:
    A : i(0) {}
    void f() {cout << "f()" << endl;}
    void f() const {cout << "f() const" << endl;}
};

int main(){
    const A a;
    a.f();

    return 0;
}
```

&emsp;&emsp;两个f()函数能构成overload的本质原因是：

```
void f(A* this)
void f(const A* this)
```

&emsp;&emsp;调用的时候因为a是const，所以会选择const的函数调用。

&emsp;&emsp;**成员变量如果是const的，那么必须在initilaizer list中将其初始化。**

## 6.4 引用

&emsp;&emsp;通过引用来访问一个对象。

&emsp;&emsp;References are a new type in C++.

```
char& r = c; //引用
```

&emsp;&emsp;全局变量或局部变量初始化时必须赋值，成员变量则不需要，会在构造函数时初始化初值。

&emsp;&emsp;引用是声明了一个新的`name`给已存在的变量。

```
int X = 47;
int& Y  = X; // Y is a reference to X

// X 和 Y 现在是同一个变量

cout << "Y  = " << Y; // Y = 47
Y = 18;
cout << "X  = " << X; // X = 18
```

### 引用的规则

* References must be initialized when defined.
* Initialization establishes a binding.

&emsp;&emsp;声明中：

```
int x = 3;
int& y = x;
const int& z = x; //通过z不能修改x
```

&emsp;&emsp;函数参数中：

```
void f( int& x );
f(y); // initialized when function is called
```

* Bindigs do not change at run time, unlike pointers.
* Assignment changes the object referred-to.

```
int& y = x;
y = 12; // changes value of x
```
* The target of a reference must have a location

```
void func(int &);
func ( i*3 ); //Warning or error! i*3 has no location!
```

### Poninters VS. References

&emsp;&emsp;**实际上，引用就是const pointers**，设计引用的目的就是减少\*号。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/reference.png" width=500px>
    <center>
    <figcaption>引用和指针的区别</figcaption>
    </center>
</figure>

&emsp;&emsp;引用类型不能互相赋值。

### 限制

&emsp;&emsp;No references to references.

&emsp;&emsp;No pointers to refereneces.

```
int&* p; //illegal 不能取得reference的地址
```

&emsp;&emsp;Reference to pointer is ok.

```
void f(int*& p); 
```
&emsp;&emsp;p是一个引用，它所bind的变量是一个指针。

&emsp;&emsp;No arrays of references.

## 6.5 向上造型（upcast）

&emsp;&emsp;子类对象被当做父类看待，同样还有向下造型（downcast）。

```
Manager pete("Pete", "111-111-111","Bakery");
Employee* ep = &pete; //Upcast
Employee& er = pete; //Upcast
```

## 6.6 多态性（Polymorphism）

&emsp;&emsp;**virtual函数**在通过指针或引用调用时不能确定是哪个，只有给了参数以后才能够确定，这里的参数就具有多态性，即指的是谁，就变成谁的形态！

&emsp;&emsp;多态性建立在两个东西的基础上，一个是upcast，另一个是dynamic binding。

* Upcast: take an object of the derived class as an object of the base one.
* Dynamic binding: binding——which function to be called. Call the function of the object. 运行时才知道调用的是哪个函数。（Static binding: call the function as the code. —— （编译时就知道调用是哪个函数）

## 6.5 多态的实现

&emsp;&emsp;任何一个类如果有虚函数，这个类的对象就会比正常的大一点。

```
#include <iostream>
using namspace std;

class A {
public:
    A() : i(10) {}
    virtual void f() {cout << "A::f()" << i << endl; }

    int i;
};

int main(){
    A a;
    a.f();
    cout << sizeof(a) << endl;

    int *p = (int*)&a;
    p++;
    cout << *p << endl; //输出为10

    return 0;
}
```

&emsp;&emsp;所有有virtual的类的对象在头上会有一个隐藏的`vptr`指针，指向存放所有virtual函数地址的`vtable`表。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/vptr指针.png" width=300px>
    <center>
    <figcaption>vptr指针指向vtable</figcaption>
    </center>
</figure>


---
layout: post
title: 【note】C++
date: 2023-7-12 
tags: C++
---

*[翁凯老师C++课程笔记](https://www.bilibili.com/video/BV1dE41167hJ/)*（每一小节的序号略有调整）。

# 1 The First C++ Program

```
#include <iostream> //文件名不是一定要有后缀的
using namespace std; // Keyword + name

int main(){
    cout << "Hello World! I am" << "18" << "today!" << endl;

    return 0;
}
```

&emsp;&emsp;输入：**cin >>**

```
#include <iostream> 
using namespace std; 

int main(){

    int age;
    cin >> age;
    cout << "You are " << age << ".";

    return 0;
}
```

擅用refactor: 重构

# 2 面向对象（Object-oriented）

## 2.1 什么是面向对象

&emsp;&emsp;Object = Entity

&emsp;&emsp;Object may be visible or invisible

&emsp;&emsp;在程序设计中，对象就是变量。如：int i; i 就是一个对象
（Object is variable in programming languages.）

&emsp;&emsp;C++中，所有的对象都会以变量的形式出现

&emsp;&emsp;对象(Objects)= 属性(Attributes) + 服务(Services)

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/object.png" width=200px>
    <center>
    <figcaption>对象</figcaption>
    </center>
</figure>

&emsp;&emsp;数据Data：属性或状态（the properties or status）

&emsp;&emsp;操作Operations：对外提供的服务（the functions）

&emsp;&emsp;对象对外有一个接口

&emsp;&emsp;Mapping(映射)：From the problem space to the solution one.

&emsp;&emsp;举例子：上课，定义一个教室，教室里有学生、老师、投影仪、电脑等，它们之间互相有一定的关系，将这个关系描述出来就是面向对象，从存在什么样的东西来分析事情，而不是从发生流程来描述一个事情。

&emsp;&emsp;从某种程度上说，C++中的class就是C中的struct

### 同一段程序C和C++对比

**C Version**
```
typedef struct point3d{
    float x;
    float y;
    float z;
}Point3d;

void Point3d_print(const Point3d* pd);
Point3d a;
a.x=1; a.y=2; a.z=3;
Point3d_print(&a);
```

**C++ Version**
```
class Point3d{
public:
    Point3d(float x, float y, float z);
    print();
private:
    float x;
    float y;
    float z;
};

Point3d a(1, 2, 3); //a是一个对象
a.print(); //operation
```

&emsp;&emsp;二者不同在于：C++操作在内部，class中有数据有操作。C的操作在外面，struct中只有操作。

&emsp;&emsp;A way to organize: Designs and Implementations.

&emsp;&emsp;对象才是Design和implementation首要关注的东西，而不是控制或数据流。

**&emsp;&emsp;To focus on things, not operations!**

## 2.2 面向对象基本概念

&emsp;&emsp;对象是互相之间在发送和接收消息。Objects send messages

### Objects send messages!

&emsp;&emsp;Messages are:

* &emsp;&emsp;composed by the sender
* &emsp;&emsp;interpreted by the receiver
* &emsp;&emsp;implemented by methods
  
&emsp;&emsp;Messages:

* &emsp;&emsp;May cause receiver to change state
* &emsp;&emsp;May return results

&emsp;&emsp;也就是说，不是在直接操作data，而是在改变operations！

### Object VS. Class

&emsp;&emsp;对象（实体）是东西，类（概念）是东西的种类。

&emsp;&emsp;杯子是一个类，我手里的杯子是一个对象。

&emsp;&emsp;**OOP Characteristics：**

* &emsp;&emsp;a. Everything is an object.
* &emsp;&emsp;b. A program is a bunch of objects telling each other what to do by sending messages.
* &emsp;&emsp;c. Each object has its own memory made up of other objects.
* &emsp;&emsp;d. Every object has a type.
* &emsp;&emsp;e. All objects of a particular type can receive the same messages

&emsp;&emsp;每一个对象有其自己的内存和类型。

&emsp;&emsp;一个特定类型的所有对象可接受相同的消息。所有可以接受相同消息的对象可以被认为是相同的类型。

&emsp;&emsp;**对象都具有接口**，对象用接口接收消息，接口的功能有Communication和Protection（保护内部的东西）。

&emsp;&emsp;**OOP三大特性：封装，继承，多态**

### 封装（Encapsulation）

&emsp;&emsp;把数据和对数据所有的操作放在一起，操作在外，数据在内。

&emsp;&emsp;隐藏数据和操作的细节。

&emsp;&emsp;外界只能访问公开的部分

# 3 类

## 3.1 以售货机为例实现一个类

&emsp;&emsp;每一个类都应该包含一个.h文件和一个.cpp文件。命名通常每个单词首字母大写。

TicketMachine.h ：
```
#ifndef TICKETMACHINE_TICKETMACHINE_H
#define TICKETMACHINE_TICKETMACHINE_H


class TicketMachine {
public:
    TicketMachine();
    virtual ~TicketMachine();
    void showPrompt();
    void insertMoney(int money);
    void showBalance();
    void printTicket();
    void showTotal();
private:
    const int PRICE;
    int balance;
    int total;

};


#endif //TICKETMACHINE_TICKETMACHINE_H
```

TicketMachine.cpp:

```
#include "TicketMachine.h"
#include <iostream>

using namespace std;

TicketMachine::TicketMachine() : PRICE(0){

}

TicketMachine::~TicketMachine() {

}

void TicketMachine::showPrompt() {
    cout << "something";
}

void TicketMachine::insertMoney(int money) {
    balance += money;
}

void TicketMachine::showBalance() {
    cout << balance;
}
```

main.cpp:
```
#include <iostream>
#include "TicketMachine.h"

int main() {
    TicketMachine tm;
    tm.insertMoney(100);
    tm.showBalance();

    return 0;
}
```

**&emsp;&emsp;特别说明：**

```
<Class Name>::<function name>
::<function name>
```

**&emsp;&emsp;::的含义：域的解析符，::前有类的名字表示函数或变量属于这个类，如果没有东西则表示一个全局的函数或变量**

```
void S::f(){
    ::f(); //全局的f()
    ::a++; //全局a
    a--; //类中的a
}
```

## 3.2 头文件

&emsp;&emsp;在头文件中包含类的声明（Class declaration）和函数的原型（prototypes），函数内容（body）放在.cpp中。注意调用头文件内容时要先include该头文件。一个头文件只声明一个类。

&emsp;&emsp;**头文件 = 接口（interface）**

&emsp;&emsp;#include：编译预处理指令。

### Declarations VS. Definitions

* &emsp;&emsp;一个.cpp就是一个编译单元
* &emsp;&emsp;只有declarations才能放在.h文件中：外部变量（extern variables）; 函数原型（function prototypes）；类和结构体的声明。

&emsp;&emsp;#include “xx.h” :在当前目录寻找头文件。 

&emsp;&emsp;#include <xx.h> :在系统目录寻找头文件。

&emsp;&emsp;#include <xx> :与第二种相同。

### 标准头文件结构

```
#ifndef 
#define

#endif
```

&emsp;&emsp;**使用这种结构是为了防止重复定义**

## 3.3 用C++实现时钟

### 抽象（Abstract）

&emsp;&emsp;Abstract is the ability to ignore details of parts to focus attention on a higher level of a problem.

## 3.4 成员变量

&emsp;&emsp;三种变量：Fields（成员变量）、parameters（函数参数）、local variables（局部变量）

* &emsp;&emsp;All three kinds of variables are able to store a value that is appropriate to their defined type.
  
* &emsp;&emsp;Fields are defined outside construators and methods.
  
* &emsp;&emsp;Fields are used to store data that persists throughout the life of an object. As such, they maintain the current state of an object. They have a lifetime that lasts as long as their object class.
  
* &emsp;&emsp;Fields have class scope: their accessibility extends throughout the whole class, and so they can be used within any of the constructors or methods of the class in which they are defined.

&emsp;&emsp;局部变量与全局变量命名重复，程序按就近原则处理。

&emsp;&emsp;成员变量：在类的所有函数中可以直接使用，属于类的每一个对象。**而函数则是属于类，不属于对象。**

```
class A{
public:
    void f();
private:
    int i; // 这里的i是声明declaration而不是定义definition
};

void A::f(){
    int j = 10;

    cout << i << endl;
    i = 20; // A的i
    cout << i << endl;
}

int main(){
    A a; 
    a.i = 10;
    cout << i << endl;
    a.f();
    cout << i << endl;

    return 0;
}
```

&emsp;&emsp;上述程序会输出：
```
10
10
20
20
```

### 成员变量的秘密

&emsp;&emsp;当用不同对象调用同一个函数时，函数"知道"是哪个对象在调用它。

```
Point a;
a.print();
```

&emsp;&emsp;There is a relationship with the function be called and the variable calls it.

&emsp;&emsp;The function itself knows it is doing something with the variable.

### this : the hidden parameter

&emsp;&emsp;**this** : 所有的成员函数都具有的一个隐藏参数，类型是class。

&emsp;&emsp;*void Point::print()* 可以写成 *void Point::print(Point *p)*。

```
class A{
public:
    void f();
private:
    int i; 
};

void A::f(){
    this->i = 20;
    printf("A::f()--&i=%p\n", &i);
    printf("this=%p", this); //this 和 i 是一样的地址
}
```

&emsp;&emsp;在成员函数中可以用this来指代变量。this不能被定义，但是可以直接使用。

## 3.5 构造与析构

&emsp;&emsp;**init变量很重要！构造函数用于确保init。**

### 构造函数（constructor）

&emsp;&emsp;构造函数名字与类相同，且没有返回类型，会在类被创建时自动被调用。构造函数也是一种成员函数。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/构造函数.png" width=400px>
    <center>
    <figcaption>构造函数与被调用的过程示意</figcaption>
    </center>
</figure>

&emsp;&emsp;构造函数也可以有参数，参数传递方法是在构造对象时在后面加一个圆括号。

```
Tree(int i) {...}
Tree t(12);
```

### 析构函数（destructor）

&emsp;&emsp;析构函数以类名称命名，并在前面加 ~ 符号。析构函数不含有参数。

```
class Y{
public:
    ~Y();
};
```

&emsp;&emsp;**析构意味着对象所占用的空间被收回，析构函数会在{}（scope）结束后被调用。**

# 4 初始化

## 4.1 对象初始化

### 存储分配

&emsp;&emsp;编译器会在{}开始就分配空间，但是构造函数是从定义对象开始的。

```
int main(){ //分配空间
    A a;
    a.i = 10;
    printf("&a = %p\n", &a);
    printf("&a.i = %p\n", &(a.i));
    A aa; //constructor happen
    a.f();
    printf("&aa = %p\n", &aa);
    aa.f();
}
```
&emsp;&emsp;C++中struct和class某种程度上是一样的，struct也可以有构造函数。

### default constructor

&emsp;&emsp;A default constructor is one that can be called with no arguments. 默认构造函数无参数。

## 4.2 new & delete

### 动态内存分配

```
new int;
new int[10];
new stash //一个类

delete p; 
delete[] p; //new 带[]则delete带[]
```

&emsp;&emsp;delete时，先析构，再收回空间。

### 动态数组

&emsp;&emsp;`int * psome = new int [10];`：动态分配一块10个int类型数据大小的空间。

&emsp;&emsp;`delete [] psome`：[]代表告诉程序delete整个数组大小的空间而不是只有第一个元素，`psome`所指的全部内容的析构都会被调用。无`[]`的话空间会被回收，但是析构只有一个会被调用。

```
int *a  = new int[10];

a++

delete [] a; // 会出错
```

### 在程序中对比 delete 和 delete[] 

**delete version :**

&emsp;&emsp;**newdelete.h** :

```
#ifndef NEW_DELETE_NEWDELETE_H
#define NEW_DELETE_NEWDELETE_H

#include <iostream>

using namespace std;

class A{
private:
    int i;
public:
    A();
    ~A();
   void set(int i);
   void f();
};

#endif //NEW_DELETE_NEWDELETE_H
```

&emsp;&emsp;**newdelete.cpp** :

```
#include "newdelete.h"

A::A() {
    int i;
    cout << "A::A()" << endl;
}

A::~A() {
    cout << "A::~A(), i = "<< i << endl;
}

void A::set(int i) {
    this->i = i;
}

void A::f() {
    cout << "hello" << endl;
}
```

&emsp;&emsp;**main.cpp** :
```
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete p;

    return 0;
}
```

&emsp;&emsp;程序输出为：

```
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 0
```

&emsp;&emsp;new的顺序是反过来的，使用delete只会析构一次。

**delete[] version :**

&emsp;&emsp;将main函数中的`delete`替换成`delete[]`

```
#include "newdelete.h"

int main() {
    int i;
    A* p = new A[10];

    for (i=0; i<10; i++){
        p[i].set(i);
    }

    delete[] p;

    return 0;
}
```

&emsp;&emsp;输出结果如下：

```
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::A()
A::~A(), i = 9
A::~A(), i = 8
A::~A(), i = 7
A::~A(), i = 6
A::~A(), i = 5
A::~A(), i = 4
A::~A(), i = 3
A::~A(), i = 2
A::~A(), i = 1
A::~A(), i = 0
```

### Tips for new and delete

* &emsp;&emsp;不要用delete释放不是被new分配的空间。
* &emsp;&emsp;不要用delete重复释放同一块空间。
* &emsp;&emsp;delete[] 和 new[] 对应。
* &emsp;&emsp;delete 和 new 对应。
* &emsp;&emsp;可以用delete释放空指针（null pointer）。

```
int *p  = 0;

delete p  //可以编译通过
```

&emsp;&emsp;这能简化代码编写，实际上，若在类中声明了一个指针并在构造函数将其定义为一个null pointer，那么析构函数有两种不同的写法。以下面的程序为例：

**first version :**

```
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

&emsp;&emsp;对于上述程序，当f()函数没有被调用过时，p是空指针，delete是safe的。当f()函数被调用过后，p不再是空指针，delete依然safe。

**更加保险的Version :**

```
class A{
private:
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void f() { p = new int; }
};
```

### delete的意义

**&emsp;&emsp;对于循环的无法关闭的程序，如手机程序等等，避免内存泄露！**

## 4.3 访问限制（Setting limits）

&emsp;&emsp;这里解释为什么有 `public` 和 `private` 之分。

&emsp;&emsp;To keep the client programmer's hands off members they should not touch.

&emsp;&emsp;To allow the library designer to change the internal workings of the structure without worring about how it will affect the client programmer.

&emsp;&emsp;对于C++来说，所有的成员有如下三种访问属性：

* pubic：公开
* private：类的成员函数可以访问
* protected：类自己和其子类可以访问

```
#include <iostream>

using namespace std;

class A{
private:
    int i;
    int *p;
public:
    A() { p = 0; cout << "hello"; }
    ~A() { if ( p ) delete p; cout << "end" << endl;}
    void set(int ii) {i = ii;}
    void f() { p = new int; }
    void g(A* q) { cout << "A::g(), q->i = "<< i << endl;}
};

int main(){
    A* p = new A[10];
    for(i=0; i<10; i++>){
        p[i].set(i);
    }

    A b;
    b.set(100);
    p[0].g(&b);
    delete p;

    return 0;
}
```

&emsp;&emsp;**`prviate`是对类来说的，而不是对对象来说的，同一个类的对象之间可以互相访问私有的成员变量。**因此上面的程序能够正常运行，将输出`A::g(), q->i = 100`。

&emsp;&emsp;C++的OOP特性只在源代码层面存在。只有在编译阶段才会检查是public还是private。

### 友元Friends

&emsp;&emsp;声明一个“朋友”，这个“朋友”可以访问private属性的东西。

```
struct X;

struct Y{
    void f(X*);
};

struct X{
private:
    int i;
public:
    void initialize();
    friend void g(X*, int); //Global friend
    friend void Y::f(X*); //Struct member friend
    friend struct Z; //Entire struct is a friend
    friend void h();
};

void X::initialize() {
    i = 0;
}

void g(X* x, int i) {
    x->i = i;
}

void Y::f(X* x) {
    x->i = 57;
}

struct Z {
private:
    int j;
}
```

### class VS. struct

&emsp;&emsp;C++中`class`与`struct`唯一的区别在于当不声明`private`还是`public`时，`class`默认为`private`而`struct`默认为`public`。

## 4.4 初始化列表

```
class Point{
private:
    const float x, y;
    Point(float xa = 0.0, float ya = 0.0):y(ya), x(xa) {}
};
```

&emsp;&emsp;x, y的初始化会早于构造函数执行。

### Initialization(初始化) VS. assignment(赋值)

**初始化：**

```
Student::Student(string s):name(s) {}
```

**赋值：**

```
Student::Student(string s) {name = s；}
```

&emsp;&emsp;这种方式先初始化了，再赋值。

&emsp;&emsp;string must have a default constructor.

&emsp;&emsp;**类中的所有成员变量都用initialize list来做初始化！不要在构造函数里面做赋值！**

# 5 软件重用

## 5.1 对象组合

&emsp;&emsp;组合：用已有的对象来制造新的对象的过程.

&emsp;&emsp;组合有两种方式：

* Fully：另一个对象是当前对象的一部分。（成员变量是对象本身）
* By reference：当前对象可以访问另一个对象，可以调用，但是它不属于当前对象的一部分。（成员变量是指针）

&emsp;&emsp;形象的比喻，孩子在母亲肚子里面时是Fully，出生后则是By reference。

&emsp;&emsp;从程序的角度来说，当设计一个“人”的对象，心脏应该是fully的（在里面）而书包一个是By reference的（在外面）。

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/组合对象.png" width=400px>
    <center>
    <figcaption>Fullyn & By reference</figcaption>
    </center>
</figure>

```
class Person {...};
class Currency {...};
class SavingAccount {
public:
    SavingAccount(const char* name, const char* address, int cents);
    ~SavingAccount();
    void print();
private:
    Person m_saver; //Fully 自己初始化自己，自己管理自己
    Currency m_balance; //Fully
};
```

&emsp;&emsp;`m_saver`和`m_balance`要遵守原来的“规范”，自己初始化自己，自己管理自己。

```
SavingAccount::SavingAccount(const char* name, const char* address, int cents): m_saver(name, address), m_balance(0, cents) {}

void SavingAccount::print() {
    m_saver.print();
    m_balance.print();
}
```

&emsp;&emsp;**这里用了初始化列表的方式来初始化`m_saver`和`m_balance`，使得二者的初始化在`SavingAccount`之前执行。如果不这样做，就要求`Person`和`Currency`两个类有default constructor。**

&emsp;&emsp;Initialize list 就是用来做这件事情的，如果类中有成员变量里面有对象，那么它应该在initialize list中完成初始化。

### Public VS. Private

&emsp;&emsp;It is common to make embedded objects private:

* they are parts of the underlying implementation.
* the new class only has parts of the public interface of the old class.

&emsp;&emsp;Can embed as a public object if you want to have the entire public interface of the subobject availaavaible in the new object.

```
class SavingAccount{
public:
    Person m_saver; // 假设Person类有set_name()函数
    ...
};

SavingAccount account;
account.m_saver.set_name("Fred");
```

## 5.2 继承（Inheritance）

&emsp;&emsp;继承：用已有的类来改造得到一个新的类。继承也是软件重用的一种方式。

&emsp;&emsp;继承和组合的区别在于，前者是用类来做出一个新的类，而后者则是用对象来制造一个新的对象。组合是“实”的，而继承是“虚”的。

&emsp;&emsp;继承使得我们可以共享设计中的成员函数、成员变量和接口（interface 指一个类的public部分）。

&emsp;&emsp; The ability to define the behaviour or implementation of one class as the **superset** of another class.

<figure>
    <img src="https://effun.xyz/images/C-plus-plus/superset继承.png" width=200px>
    <center>
    <figcaption>“学生”继承“人，因为学生是人！</figcaption>
    </center>
</figure>



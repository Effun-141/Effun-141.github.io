---
layout: post
title:  "ESVO2代码详解"
info: "阅读ESVO2代码并解释核心功能"
tech: " "
type: Brief introduction 
---

**写在前面的：详细阅读事件-惯性SLAM开源框架[ESVO2](https://github.com/NAIL-HNU/ESVO2)代码，解释代码逻辑和核心功能。另外，感谢作者的开源工作！**

### **相关工作**

[1] **[ESVO2: Direct Visual-Inertial Odometry with Stereo Event Cameras](https://arxiv.org/abs/2410.09374)**, *Junkai Niu, Sheng Zhong, Xiuyuan Lu, Shaojie Shen, Guillermo Gallego, Yi Zhou*, arxiv. [PDF](https://arxiv.org/abs/2410.09374).

[2] **[IMU-Aided Event-based Stereo Visual Odometry](https://arxiv.org/abs/2405.04071)**, *Junkai Niu, Sheng Zhong, Yi Zhou*, ICRA 2024. [PDF](https://arxiv.org/pdf/2405.04071).

[3] **[Event-based Stereo Visual Odometry](https://arxiv.org/abs/2007.15548)**, *Yi Zhou, Guillermo Gallego, Shaojie Shen*, IEEE Transactions on Robotics (T-RO), 37(5):1433-1450, 2021. [Project page](https://sites.google.com/view/esvo-project-page/home), [PDF](https://arxiv.org/pdf/2007.15548).

[4] **[Semi-dense 3D Reconstruction with a Stereo Event Camera](https://arxiv.org/abs/1807.07429)**, *Yi Zhou, Guillermo Gallego, Henri Rebecq, Laurent Kneip, Hongdong Li, Davide Scaramuzza*, ECCV 2018. [PDF](http://rpg.ifi.uzh.ch/docs/ECCV18_Zhou.pdf).

#### 整体逻辑: 

<table rules="none" align="center">
	<tr>
		<td>
			<center>
				<img src="https://effun.xyz/assets/img/20250117/Quicker_20250119_012256.png" width="100%" />
				<br/>
				<font color="AAAAAA"></font>
			</center>
		</td>
	</tr>
</table>

## &#127774;ImageRepresentation 节点

### &#9889;Structure

**1.构造函数ImageRepresentation::ImageRepresentatio:**

```
/**
   * todo:构造函数：初始化ImageRepresentation类
   * @param nh ROS节点句柄
   * @param nh_private ROS私有节点句柄
   * 功能：
   * 1. 设置ROS话题订阅和发布
   * 2. 加载参数配置
   * 3. 启动图像生成线程
   */
  ImageRepresentation::ImageRepresentation(ros::NodeHandle &nh, ros::NodeHandle nh_private) : nh_(nh)

```

**2.析构函数ImageRepresentation::~ImageRepresentation**

**3.类初始化函数ImageRepresentation::init(int width, int height):**

```
/**
   * todo:类初始化函数
   * @param width 图像宽度
   * @param height 图像高度
   * 功能：
   * 1. 初始化传感器尺寸
   * 2. 初始化图像表示矩阵
   * 3. 预分配事件向量内存
   */
  void ImageRepresentation::init(int width, int height)
```

**4.图像生成主循环ImageRepresentation::GenerationLoop:**

```
/**
  * todo:图像生成主循环
  * 功能：
  * 1. 按指定频率生成图像表示
  * 2. 调用createImageRepresentationAtTime处理事件
  */
  void ImageRepresentation::GenerationLoop()
```

**5.自适应累积(AA)处理线程ImageRepresentation::AA_thread:**
```
/**
   * todo:自适应累积(AA)处理线程
   * @param ptr_e 事件迭代器
   * @param distance 处理的事件距离
   * @param external_t 外部时间
   * 功能：
   * 1. 实现自适应累积算法
   * 2. 生成AA图像表示
   * 3. 发布AA相关图像
   */
  void ImageRepresentation::AA_thread(std::vector<dvs_msgs::Event>::iterator &ptr_e, int distance, double external_t)
```

**6.在指定时间点创建图像表示ImageRepresentation::createImageRepresentationAtTime:**
```
/**
   * todo:在指定时间点创建图像表示
   * @param external_sync_time 外部同步时间
   * 功能：
   * 1. 生成时间表面(TS)表示
   * 2. 生成累积帧(AA)表示
   * 3. 处理图像畸变校正
   * 4. 发布各种图像表示
   */
  void ImageRepresentation::createImageRepresentationAtTime(const ros::Time &external_sync_time)
```

**7.清理指定距离内的事件函数ImageRepresentation::clearEvents**

**8.事件回调函数ImageRepresentation::eventsCallback:**
```
/**
  * todo:事件回调函数
  * @param msg 事件数组消息
  * 功能：
  * 1. 接收和处理新的事件
  * 2. 维护事件队列
  * 3. 触发图像生成
  */
  void ImageRepresentation::eventsCallback(const dvs_msgs::EventArray::ConstPtr &msg)
```

**9.清空事件队列，释放内存函数ImageRepresentation::clearEventQueue**

**10.Sobel边缘检测处理函数ImageRepresentation::sobel**

**11.加载相机标定信息函数ImageRepresentation::loadCalibInfo：**
```
 /**
   * todo:加载相机标定信息
   * @param cameraSystemDir 标定文件目录
   * @param is_left 是否为左相机
   * @return 加载是否成功
   * 功能：
   * 1. 从YAML文件加载相机参数
   * 2. 计算去畸变映射
   * 3. 预计算校正查找表
   */
  bool ImageRepresentation::loadCalibInfo(const std::string &cameraSystemDir, bool &is_left)
```

**12.检查文件是否存在函数ImageRepresentation::fileExists**

### &#10024;核心功能——生成时间表面TimeSurface以及自适应累积图AA map

函数：`void ImageRepresentation::createImageRepresentationAtTime(const ros::Time &external_sync_time)`

TimeSureface(TS)的数学原理：由于event是一个串行异步数据流，所以期望能够对其进行类似于图像的表征，以服务于后续的位姿估计。

TS是一种2D图像表示，其中每个像素存储一个时间值，计算公式为：

<div>

$$\mathcal{T}(\mathbf{x},t) = \exp\left(-\frac{t-t_{\text{last}}(\mathbf{x})}{\eta}\right)$$

</div>

时间表面函数$\mathcal{T}(\mathbf{x},t)$中，$\mathbf{x} = (u,v)$表示像素坐标，$t$代表当前时间，$t_{\text{last}}(\mathbf{x})$表示在该像素位置最后一个事件的时间戳，$\eta$是衰减率参数(通常设置为30ms)。该函数的值域为[0,1]，在实际可视化时会被缩放到[0,255]的范围内。

```
    // 4.1 启动AA处理线程
std::thread thread0(&ImageRepresentation::AA_thread, this, std::ref(ptr_e), distance, external_t);
	// 4.2 生成TS(时间表面)
representation_TS_.setTo(cv::Scalar(0));
cv::Mat TS_img = cv::Mat::zeros(sensor_size_, CV_64F);

// if the event rate is too high, we need to downsample the events
// step = 1 indicates that we use all the events
// double step = static_cast<double>(distance) / 90000.0;

double step = 1;
std::vector<dvs_msgs::Event>::iterator it = vEvents_.begin();

   // 4.3 生成时间表面映射 更新每个像素的最新事件时间
for (int i = 0; i < distance; i++)
{
	int index = static_cast<int>(i * step);
	if (index > distance - 2)
	break;
	dvs_msgs::Event e = *(it + index);
	TS_temp_map(e.y, e.x) = e.ts.toSec() / decay_sec_; // 归一化时间戳
}

	// 4.4 时间表面计算
cv::eigen2cv(TS_temp_map, representation_TS_);
representation_TS_ = representation_TS_ - external_t / decay_sec_;  // 减去参考时间
cv::exp(representation_TS_, representation_TS_); // 指数衰减

	// 4.5 转换为图像格式
TS_img = representation_TS_ * 255.0;
TS_img.convertTo(TS_img, CV_8U);
```

对于TS的生成，`TS_temp_map(e.y, e.x) = e.ts.toSec() / decay_sec_;`对应指数因子的前半部分，而当我们用一个矩阵减去一个标量值时，OpenCV会自动将这个标量"广播"到与矩阵相同的尺寸，即对矩阵中的每个元素都减去这个标量值，对应`representation_TS_ = representation_TS_ - external_t / decay_sec_`。这样就与TS公式对应起来了。